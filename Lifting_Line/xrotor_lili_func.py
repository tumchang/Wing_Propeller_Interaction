"""
============================================================================
This script stored the classes, functions, methods for the
xfoil --> xrotor --> Lifting Line workflow

main script name: xrotor_liftingline_main

Xfoil: https://web.mit.edu/drela/Public/web/xfoil/
Xrotor: https://web.mit.edu/drela/Public/web/xrotor/
Lifting Line: https://www.dlr.de/as/en/desktopdefault.aspx/tabid-188/379_read-625/
-------------
Author: Chang Xu   TUM   03739064  August.2023
Supervisor: Yiyuan Ma & Alexandros Lessis

Copyright @ Bauhaus Luftfahrt e.V
============================================================================
"""

# Module import
import xmltodict
import math
import xml.etree.ElementTree as ET
from xrotor import XRotor
from xrotor.model import Case
from scipy.optimize import minimize
from Lifting_Line_Visualization import *
from VSP.cpacs_vsp_wrapper import *


class OperPNT:
    def __init__(self):
        self.beta_70 = None
        self.rho = None
        self.hub_radius = None
        self.tip_radius = None
        self.RPM_list = None
        self.Vinf = None
        self.B = None


class AirfoilPolar:
    """
    get basic data from airfoil polar file generated by Xfoil and store the data
    """

    def __init__(self, polar_file_dir):
        self.airfoil = None
        alpha_list = []
        CL_list = []
        CD_list = []
        CDp_list = []
        CM_list = []
        Top_Xtr_list = []
        Bot_Xtr_list = []

        with open(polar_file_dir, 'r') as file:
            # Read the Airfoil Name
            for line in file:
                if "Calculated polar for:" in line:
                    self.airfoil = line.split(":")[1].strip()

            # Reset the file's pointer to the beginning
            file.seek(0)

            # Skip header lines
            for i in range(12):
                next(file)

            # Process each data line
            for line in file:
                values = line.split()

                alpha_list.append(float(values[0]))
                CL_list.append(float(values[1]))
                CD_list.append(float(values[2]))
                CDp_list.append(float(values[3]))
                CM_list.append(float(values[4]))
                Top_Xtr_list.append(float(values[5]))
                Bot_Xtr_list.append(float(values[6]))

        # Calculate Cl.potential using Cl.p = 2*pi*alpha
        CL_pot_list = []
        for alpha in alpha_list:
            CL_pot_list.append(
                np.radians(alpha) * 2 * np.pi
            )

        # Convert lists to numpy arrays
        self.alpha = np.array(alpha_list)
        self.CL = np.array(CL_list)
        self.CD = np.array(CD_list)
        self.CDp = np.array(CDp_list)
        self.CM = np.array(CM_list)
        self.Top_Xtr = np.array(Top_Xtr_list)
        self.Bot_Xtr = np.array(Bot_Xtr_list)
        self.CL_pot = np.array(CL_pot_list)
        self.alpha_rad = np.radians(self.alpha)

    def get_cl_at_cdmin(self):
        # Polynomial fitting
        z = np.polyfit(self.alpha, self.CD, 2)
        p = np.poly1d(z)

        # Minimize the polynomial to get the angle of attack corresponding to min CD
        alpha_at_cdmin = minimize(p, -10).x[0]  # We assume starting from 0 degree AoA

        # Interpolate to get the corresponding CL
        cl_at_cdmin = np.interp(alpha_at_cdmin, self.alpha, self.CL)

        return cl_at_cdmin

    def get_dCDdCL2(self):
        CL = self.CL
        CD = self.CD

        coeffs = np.polyfit(CL ** 2, CD, 1)

        # The coefficient k is the slope of the line (since it's linear with respect to CL^2)
        k = coeffs[0]

        return k


class PropellerSec:

    def __init__(self):
        self.r_avg = None
        self.dr = None


class ResultBEM:

    def __init__(self):
        self.a = None
        self.a_prime = None
        self.Cl = None
        self.Cd = None
        self.F = None


class PropellerGeom:
    """
    hold the Propeller Geometry Data
    """

    def __init__(self, geomdata):
        self.r_R = geomdata[:, 0]
        self.c_R = geomdata[:, 1]
        self.t_c = geomdata[:, 2]
        self.beta = geomdata[:, 3]
        self.section = PropellerSec()


class Propeller:
    """
    hold the Propeller data such as geometry and the
    airfoil polar data
    """

    def __init__(self, polar_file_dir, geom_dist, oper_pnt, RPM):
        # hold data for the prop operate condition

        self.airfoil_polar = AirfoilPolar(polar_file_dir)
        self.geometry = PropellerGeom(geom_dist)
        self.rho = oper_pnt.rho
        self.hub_radius = oper_pnt.hub_radius
        self.tip_radius = oper_pnt.tip_radius
        self.RPM = RPM
        self.omega = (RPM * 2 * np.pi) / 60
        self.Vinf = oper_pnt.Vinf
        self.B = oper_pnt.B
        self.n = RPM / 60
        self.J = oper_pnt.Vinf / ((RPM / 60) * (2 * oper_pnt.tip_radius))
        self.beta_70 = oper_pnt.beta_70
        self.Result_BEM = ResultBEM()
        self.local_v = None

        self.polar_for_xr = np.column_stack((self.airfoil_polar.alpha, self.airfoil_polar.CL,
                                             self.airfoil_polar.CD, self.airfoil_polar.CM))

    # Generate propeller sections using Geometry defined
    def generate_prop_section(self):
        # Get the absolute chord length and r position propeller sections
        self.geometry.c = self.geometry.c_R * self.tip_radius
        self.geometry.r = self.geometry.r_R * self.tip_radius

        # Calculate the middle point r position for each section
        r_avg = []
        for i in range(len(self.geometry.r_R) - 1):
            r_avg.append(
                (self.geometry.r[i] + self.geometry.r[i + 1]) / 2
            )
        r_avg = np.asarray(r_avg)
        self.geometry.section.r_avg = r_avg

        # Calculate the section length
        dr = []
        for i in range(len(self.geometry.r_R) - 1):
            dr.append(
                self.geometry.r[i + 1] - self.geometry.r[i]
            )
        dr = np.asarray(dr)
        self.geometry.section.dr = dr

        # Get the local speed of each section
        self.local_v = np.sqrt(self.Vinf ** 2 + (self.geometry.r * self.omega) ** 2)

        return

    def calculate_thrust(self):
        # Get the average tip loss factor in one section
        F_avg = []
        for i in range(len(self.Result_BEM.Cl) - 1):
            F_avg.append(
                (self.Result_BEM.F[i] + self.Result_BEM.F[i + 1]) / 2
            )
        F_avg = np.asarray(F_avg)

        # Get the average axial induced speed factor in one section
        a_avg = []
        for i in range(len(self.Result_BEM.Cl) - 1):
            a_avg.append(
                (self.Result_BEM.a[i] + self.Result_BEM.a[i + 1]) / 2
            )
        a_avg = np.asarray(a_avg)

        # Get the average tangential induced speed factor in one section
        a_prime_avg = []
        for i in range(len(self.Result_BEM.Cl) - 1):
            a_prime_avg.append(
                (self.Result_BEM.a_prime[i] + self.Result_BEM.a_prime[i + 1]) / 2
            )
        a_prime_avg = np.asarray(a_prime_avg)

        # Calculation of Thrust dT for each section
        dT = (
                (2 * F_avg * self.rho * self.Vinf * self.Vinf) *
                (a_avg * (1 + a_avg)) *
                (2 * np.pi * self.geometry.section.r_avg) *
                self.geometry.section.dr
        )

        # Total Thrust
        T = sum(dT)

        # Calculation of Ct
        Ct = T / (
                self.rho * (self.n ** 2) * ((self.tip_radius * 2) ** 4)
        )

        # Calculation of Torque dQ for each section
        dQ = (
                2 * F_avg * a_prime_avg *
                (1 + a_avg) * self.rho * self.Vinf *
                self.omega *
                self.geometry.section.r_avg * self.geometry.section.r_avg *
                (2 * np.pi * self.geometry.section.r_avg) *
                self.geometry.section.dr
        )

        # Q = sum(dQ)

        dP = self.omega * dQ

        P = sum(dP)

        Cp = P / (
                self.rho * (self.n ** 3) * ((self.tip_radius * 2) ** 5)
        )

        # Versuch Axial induced Velocity
        # Va = np.sqrt(
        #     (self.Vinf * self.Vinf / 4) +
        #     (dT / 4 * self.rho * np.pi * self.geometry.section.r_avg)
        #              ) - (self.Vinf/2)

        return T, Ct, Cp


def validation_geomdata():
    geom_data = np.array([
        # r/R  c/R    t/c     beta
        [0.15, 0.141, 0.100, 31.67],
        [0.20, 0.147, 0.100, 37.59],
        [0.25, 0.183, 0.100, 38.78],
        [0.30, 0.207, 0.100, 35.90],
        [0.35, 0.218, 0.100, 32.07],
        [0.40, 0.223, 0.100, 28.50],
        [0.45, 0.222, 0.100, 25.81],
        [0.50, 0.217, 0.100, 23.58],
        [0.55, 0.209, 0.100, 21.66],
        [0.60, 0.197, 0.100, 19.99],
        [0.65, 0.183, 0.100, 18.58],
        [0.70, 0.167, 0.100, 17.29],
        [0.75, 0.150, 0.100, 16.37],
        [0.80, 0.132, 0.100, 15.46],
        [0.85, 0.114, 0.100, 14.30],
        [0.90, 0.098, 0.100, 13.40],
        [0.95, 0.075, 0.100, 12.02],
        [1.00, 0.051, 0.100, 10.61]
    ])

    # Create the interpolation functions for each column
    func_c_R = interp1d(geom_data[:, 0], geom_data[:, 1], kind='cubic')
    func_t_c = interp1d(geom_data[:, 0], geom_data[:, 2], kind='cubic')
    func_beta = interp1d(geom_data[:, 0], geom_data[:, 3], kind='cubic')

    # Create a denser r/R array. Here, for example, we interpolate at intervals of 0.025 instead of 0.05.
    dense_r_R = np.arange(0.15, 1.0000, 0.01)

    # Use the dense r/R values to get interpolated values for the other columns
    dense_c_R = func_c_R(dense_r_R)
    dense_t_c = func_t_c(dense_r_R)
    dense_beta = func_beta(dense_r_R)

    # Stack them together to get the new denser geom_data
    dense_validation_geomdata = np.column_stack((dense_r_R, dense_c_R, dense_t_c, dense_beta))

    return dense_validation_geomdata


def geomdata(beta_70=55.31):
    step = 2.21
    geom_data = np.array([
        # r/R     c/R     t/c     beta
        [0.2000, 0.0759, 0.7977, beta_70 + 10 * step],
        [0.2500, 0.0904, 0.5492, beta_70 + 9 * step],
        [0.3000, 0.1062, 0.3635, beta_70 + 8 * step],
        [0.3500, 0.1226, 0.2405, beta_70 + 7 * step],
        [0.4000, 0.1382, 0.1748, beta_70 + 6 * step],
        [0.4500, 0.1480, 0.1366, beta_70 + 5 * step],
        [0.5000, 0.1520, 0.1182, beta_70 + 4 * step],
        [0.5500, 0.1503, 0.1078, beta_70 + 3 * step],
        [0.6000, 0.1461, 0.1015, beta_70 + 2 * step],
        [0.6500, 0.1393, 0.0955, beta_70 + 1 * step],
        [0.7000, 0.1313, 0.0915, beta_70],
        [0.7500, 0.1224, 0.0884, beta_70 - 1 * step],
        [0.8000, 0.1121, 0.0855, beta_70 - 2 * step],
        [0.8500, 0.1010, 0.0839, beta_70 - 3 * step],
        [0.9000, 0.0886, 0.0818, beta_70 - 4 * step],
        [0.9500, 0.0752, 0.0812, beta_70 - 5 * step],
        [1.0000, 0.0652, 0.0800, beta_70 - 6 * step],
    ])

    # Create the interpolation functions for each column
    # func_c_R = interp1d(geom_data[:, 0], geom_data[:, 1], kind='linear', fill_value="extrapolate")
    # func_t_c = interp1d(geom_data[:, 0], geom_data[:, 2], kind='linear', fill_value="extrapolate")
    # func_beta = interp1d(geom_data[:, 0], geom_data[:, 3], kind='linear', fill_value="extrapolate")

    func_c_R = interp1d(geom_data[:, 0], geom_data[:, 1], kind='cubic')
    func_t_c = interp1d(geom_data[:, 0], geom_data[:, 2], kind='cubic')
    func_beta = interp1d(geom_data[:, 0], geom_data[:, 3], kind='cubic')

    # Create a denser r/R array. Here, for example, we interpolate at intervals of 0.025 instead of 0.05.
    dense_r_R = np.arange(0.2000, 1.000, 0.015)

    # Use the dense r/R values to get interpolated values for the other columns
    dense_c_R = func_c_R(dense_r_R)
    dense_t_c = func_t_c(dense_r_R)
    dense_beta = func_beta(dense_r_R)

    # Stack them together to get the new denser geom_data
    dense_geom_data = np.column_stack((dense_r_R, dense_c_R, dense_t_c, dense_beta))

    return dense_geom_data


def case(propeller):
    geom_data = geomdata(beta_70=propeller.beta_70)
    # geom_data = validation_geomdata()

    # geom_data = ten_eight_MLH_geomdata()
    #     np.array([
    #     # r/R     c/R     t/c     beta
    #     [0.2000, 0.0759, 0.7977, 77.5],
    #     [0.2500, 0.0904, 0.5492, 75.28],
    #     [0.3000, 0.1062, 0.3635, 73.06],
    #     [0.3500, 0.1226, 0.2405, 70.84],
    #     [0.4000, 0.1382, 0.1748, 68.63],
    #     [0.4500, 0.1480, 0.1366, 66.41],
    #     [0.5000, 0.1520, 0.1182, 64.19],
    #     [0.5500, 0.1503, 0.1078, 61.97],
    #     [0.6000, 0.1461, 0.1015, 59.75],
    #     [0.6500, 0.1393, 0.0955, 57.53],
    #     [0.7000, 0.1313, 0.0915, 55.31],
    #     [0.7500, 0.1224, 0.0884, 53.09],
    #     [0.8000, 0.1121, 0.0855, 50.88],
    #     [0.8500, 0.1010, 0.0839, 48.66],
    #     [0.9000, 0.0886, 0.0818, 46.44],
    #     [0.9500, 0.0752, 0.0812, 44.22],
    #     [1.000, 0.0652, 0.0800, 42],
    # ])
    # geom_data[:, 3] -= 5

    case_setting = {
        'conditions': {
            # Standard atmosphere at sea level
            'rho': 1.225,
            'vso': 340,
            'rmu': 1.789e-5,
            'alt': 1,
            # Operating conditions in accordance with NASA Report No. 640
            # adv = V / (Omega * R) = V / (RPM * pi/30 * R)
            # 'vel': 142,
            # 'adv': 0.90159
            'vel': propeller.Vinf,
            'adv': propeller.J
        },
        'disk': {
            'n_blds': propeller.B,
            'blade': {
                'geometry': {
                    # TODO: Get the parameter of the Hamilton F568 Propeller
                    'r_hub': propeller.hub_radius,
                    'r_tip': propeller.tip_radius,
                    'r_wake': 0.0,
                    'rake': 0.0,
                    'radii': geom_data[:, 0],
                    'chord': geom_data[:, 1],
                    'twist': geom_data[:, 3],
                    'ubody': np.zeros_like(geom_data[:, 0])
                },
                'polars': {
                    0.0: propeller.polar_for_xr
                }
            }
        },
        'settings': {
            'free': True, 'duct': False, 'wind': False
        }
    }

    return case_setting


def operate_xrotor(cases, RPM):
    xr = XRotor()
    xr.max_iter = 100
    xr.case = Case.from_dict(cases)

    xr.operate(rpm=RPM)

    xr.print_case()

    return xr


def vput_xr(xr, rpm, print_flag=False):
    """
    This function is used for extracting slip stream output of XROTOR results
    :param print_flag: flag to save the data to a txt file
    :param rpm: RPM
    :param xr: xrotor class
    :return: TXT file under X_ROTOR directory, slipstream data

    """
    r_norm = xr.station_conditions[0]
    vt = xr.station_conditions[8]
    va = xr.station_conditions[9]

    data = np.vstack((r_norm, va, vt)).T

    header_str = "r_norm     va     vt"
    if print_flag:
        np.savetxt(f"./X_ROTOR/B{xr.case.disk.n_blds}_vel{xr.case.conditions.vel}_rpm{rpm}.txt",
                   data, header=header_str, delimiter="\t", comments="", fmt="%.5f")

    return data


def xr_postprocess(xr):
    """
    This function is used for calculating Section parameters
    such as a a' F, based on Xrotor Cl,Cd value

    :param xr:
    :return:
    """
    # TODO:  Project not completed!!!!!!!!!!!
    # Get the local AOA from Cl values from Xrotor results
    local_alpha = np.interp(xr.station_conditions[3],
                            xr.case.disk.blade.polardata[:, 1],
                            xr.case.disk.blade.polardata[:, 0]
                            )

    # Get the local twist
    func_r_twist = interp1d(xr.case.disk.blade.geomdata[0, :],
                            xr.case.disk.blade.geomdata[2, :],
                            kind='cubic',
                            fill_value="extrapolate")

    r_R = xr.station_conditions[0]
    local_twist = func_r_twist(r_R)

    # Get the local phi [deg]
    local_phi_deg = local_twist - local_alpha
    # Change to radians
    local_phi = np.radians(local_phi_deg)

    # Calculation of Cn and Ct
    Cn_xr = (xr.station_conditions[3] * np.cos(local_phi)
             -
             xr.station_conditions[4] * np.sin(local_phi)
             )

    # Tangential Direction
    Ct_xr = (xr.station_conditions[3] * np.sin(local_phi)
             +
             xr.station_conditions[4] * np.cos(local_phi)
             )

    # Calculation of Tip loss factor F
    # TODO: do research of the Tip loss model used by XRotor
    # Ref = E.E. Larrabee. Practical Design of Minimum Induced Loss Propellers. SAE Technical Paper, 1979.
    f = (
            (xr.case.disk.n_blds / 2) *
            ((xr.case.conditions.adv ** 2 + 1) ** 0.5) / xr.case.conditions.adv *
            (1 - xr.station_conditions[0])
    )

    F = (2 / np.pi) * np.arccos(np.exp(-f))

    # Calculation of a and a'
    # Get local chord length
    func_c_r = interp1d(xr.case.disk.blade.geomdata[0, :],
                        xr.case.disk.blade.geomdata[1, :],
                        kind='cubic',
                        fill_value="extrapolate")

    local_chord = func_c_r(xr.station_conditions[0])

    sigma_r_xr = (
            (xr.case.disk.n_blds * local_chord * xr.case.disk.blade.geometry.r_tip)
            /
            (2 * np.pi * (xr.station_conditions[0] * xr.case.disk.blade.geometry.r_tip))
    )

    a_xr = 1 / (((4 * F * np.sin(local_phi) ** 2) / (sigma_r_xr * Cn_xr)) - 1)
    a_prime_xr = 1 / (((4 * F * np.sin(local_phi) * np.cos(local_phi)) / (sigma_r_xr * Ct_xr)) + 1)

    # Calculation of dr
    dr_R_xr = [xr.station_conditions[0][0] - xr.case.disk.blade.geomdata[0, 0]]

    for i in range(len(xr.station_conditions[0]) - 1):
        dr_R_xr.append(xr.station_conditions[0][i + 1]
                       -
                       xr.station_conditions[0][i]
                       )
    dr_R_xr = np.array(dr_R_xr)

    dr_xr = dr_R_xr * xr.case.disk.blade.geometry.r_tip

    # Calculation of dT
    dT_xr = (
            (2 * F * xr.case.conditions.rho) *
            (xr.case.conditions.vel * xr.case.conditions.vel) *
            a_xr * (1 - a_xr) *
            2 * np.pi *
            (xr.station_conditions[0] * xr.case.disk.blade.geometry.r_tip) *
            dr_xr
    )

    T_xr = sum(dT_xr)

    return T_xr


def slipstream_normalize(slip, xr):

    slip_norm = slip.copy()
    slip_norm[:, 1:] = slip_norm[:, 1:] / xr.case.conditions.vel

    return slip_norm


def add_slipstream(cpacs_ref, slipstream, RPM, prop_flag=True):
    """
    :param RPM:
    :param prop_flag: Turn on or Turn off Propeller rotation
    :param cpacs_ref: CPACS reference file
    :param slipstream: slipstream from XRotor results
    :return:
    """
    if not prop_flag:
        RPM = 0

    # Read the CPACS Reference XML file
    tree = ET.parse(cpacs_ref)
    root = tree.getroot()

    # Define the namespace in order to find the Velocity Field
    namespace = {"ll": "http://www.cpacs.de/liftingLine"}

    # Get the name of aircraft for naming proposes
    for elem in root.findall(".//header/name", namespaces=namespace):
        aircraft_name = elem.text

    # Turn on or turn off propeller Module
    for elem in root.findall(".//ll:usePropModule", namespaces=namespace):
        if prop_flag:
            elem.text = 'true'
        else:
            elem.text = 'false'

    # R_station to be interpolated
    r_lili = np.linspace(slipstream[0, 0], slipstream[-1, 0], 20)

    # Get the number of Angles
    for elem in root.findall(".//ll:numberOfAngles", namespaces=namespace):
        angle_num = int(elem.text)

    # Change the number of r stations to match input slipstream
    # There is a max r station restriction in LILI( [1, 21] ) !!!!!!!!!!!
    # !!!! Interpolation needed !!!!
    for elem in root.findall(".//ll:numberOfRelativeRadii", namespaces=namespace):
        elem.text = str(r_num := 20)

    # Add relative r stations
    for elem in root.findall(".//ll:relativeRadii", namespaces=namespace):
        r_station = np.repeat(r_lili.reshape(-1, 1), angle_num, axis=1)
        r_station = r_station.T.flatten()
        r_station_str = ';'.join(map(str, r_station))  # change to str, use ; as divider
        elem.text = r_station_str

    # Add angles
    for elem in root.findall(".//ll:angles", namespaces=namespace):
        angle = np.linspace(0, 360, angle_num + 1)
        angle = angle[:-1]
        angle = np.repeat(angle.reshape(-1, 1), r_num, axis=1)
        angle = angle.flatten()
        angle_str = ';'.join(map(str, angle))
        elem.text = angle_str

    # Add axial induced speed
    for elem in root.findall(".//ll:relativeAxialFlowSpeeds", namespaces=namespace):
        axial_interp = np.interp(r_lili, slipstream[:, 0], slipstream[:, 1])
        axial = np.repeat(axial_interp.reshape(-1, 1),
                          angle_num, axis=1)
        axial = axial.T.flatten()
        axial_str = ';'.join(map(str, axial))  # change to str, use ; as divider
        elem.text = axial_str

    # Add tangential induced Speed
    for elem in root.findall(".//ll:relativeTangentialFlowSpeeds", namespaces=namespace):
        tangential_interp = np.interp(r_lili, slipstream[:, 0], slipstream[:, 2])
        tangential = np.repeat(tangential_interp.reshape(-1, 1),
                               angle_num, axis=1)
        tangential = tangential.T.flatten()
        tangential_str = ';'.join(map(str, tangential))
        elem.text = tangential_str

    # for elem in root.findall(".//ll:chordwise", namespaces=namespace):
    #     text = elem

    # Write the modified xml
    write_path = f'./LILI/{aircraft_name}/prop{prop_flag}_RPM{RPM}'
    # Check if the directory exists or not
    if os.path.exists(write_path):
        if prop_flag:
            xml_path = write_path + f'/prop{prop_flag}_RPM{RPM}.xml'
            tree.write(xml_path)
        else:
            xml_path = write_path + f'/propoff.xml'
            tree.write(xml_path)
    else:
        os.makedirs(write_path)
        if prop_flag:
            xml_path = write_path + f'/prop{prop_flag}_RPM{RPM}.xml'
            tree.write(xml_path)
        else:
            xml_path = write_path + f'/propoff.xml'
            tree.write(xml_path)

    print(f'New {aircraft_name} XML file for LILI Analysis created')

    return xml_path


def run_lili(lili_exe_path, xml_path):
    # Get the folder where the xml file is stored
    xml_dir = os.path.dirname(xml_path)

    # Start the lili.exe without blocking and set up communication pipes
    process = subprocess.Popen(lili_exe_path,
                               stdin=subprocess.PIPE,
                               stdout=subprocess.PIPE,
                               stderr=subprocess.PIPE,
                               text=True)

    # Specify the cpacs input file directory
    process.stdin.write(f"{xml_path}\n")
    process.stdin.flush()
    time.sleep(0.5)  # adjust this delay as needed

    process.stdin.write("output\n")
    process.stdin.flush()
    time.sleep(0.5)

    # Close stdin when done sending commands
    process.stdin.close()

    # Capture output if needed
    output = process.stdout.read()
    print(output)

    # Ensure the process finishes
    process.wait()

    # Copy the LILI ReturnDirectory folder to the xml_dir
    # If destination exists, remove it
    if os.path.exists(xml_dir + '/ReturnDirectory'):
        shutil.rmtree(xml_dir + '/ReturnDirectory')

    shutil.move('./ReturnDirectory', xml_dir)

    return xml_dir


def lili_visualization(xml_dir, save_plot=False):
    aircraft_name = "CPACS4LILI_LILI-Config_1"

    # Get the Overall Lift to Drag ratio

    tecplot_dir = xml_dir + '/ReturnDirectory/CPACS4LILI_LILI-Config_1.lili.V3.1/export/tecplot'
    total_tecplot_dir = xml_dir + '/ReturnDirectory'

    geom_secs = parse_attributes(tecplot_dir, aircraft_name)
    distribution, distribution_dict = parse_distribution(tecplot_dir, aircraft_name)
    total_distribution = parse_total_dist(total_tecplot_dir)
    total_coeff = parse_distribution(tecplot_dir, aircraft_name, parse_total=True)

    CD = float(total_coeff[0]['CFX_FROM_CDI'])
    CL = float(total_coeff[0]['CFZ'])

    fig1 = panel_dist_plot(distribution_dict, "CFZ", geom_secs,
                           3, mesh_flag=False)

    fig2, df_cl = cl_distribution_2d(total_distribution)
    fig3, df_Fz = lift_distribution_2d(total_distribution)

    # Save the cl and Lift distribution to csv
    df_cl.to_csv(xml_dir + '/cl_dist.csv', index=False)
    df_Fz.to_csv(xml_dir + '/Fz_dist.csv', index=False)

    # Save the plot if necessary
    if save_plot:
        dpi = 600

        # List of desired view angles (elev, azim)
        view_angles = [(30, -135), (0, 180)]  # Example angles
        ax1 = fig1.axes[0]  # assuming there's only one axis in fig1

        for elev, azim in view_angles:
            ax1.view_init(elev=elev, azim=azim)
            filename = f'panel_dist_plot_{elev}_{azim}.png'
            fig1.savefig(os.path.join(xml_dir, filename), dpi=dpi)

        fig2.savefig(os.path.join(xml_dir, 'cl_distribution.png'), dpi=dpi)
        fig3.savefig(os.path.join(xml_dir, 'lift_distribution.png'), dpi=dpi)

    # Show all the figures
    # plt.show()

    return CL, CD, total_coeff[0]

# def a_phi_equations(vars, cl_val, cd_val):
#     a, phi = vars
#     eq1 = 4 * a * (1 + a) * np.cos(phi) - cl_val
#     eq2 = 4 * a * (1 + a) * np.sin(phi) - cd_val
#     return [eq1, eq2]
#
#
# def solve_a_phi(xr):
#     cl_array = xr.station_conditions[3]  # CL values from Xrotor
#     cd_array = xr.station_conditions[4]  # CD values from Xrotor
#
#     # Initial guesses for a and phi
#     a_guess = 0.6
#     phi_guess = np.pi / 2
#
#     # Iterate through arrays and solve the system for each pair
#     a_values = []
#     phi_values = []
#
#     for cl_val, cd_val in zip(cl_array, cd_array):
#         a, phi = fsolve(a_phi_equations, (0.6, phi_guess), args=(cl_val, cd_val))
#         a_values.append(a)
#         phi_values.append(phi)
#
#     # Convert results to numpy arrays
#     a_values = np.array(a_values)
#     phi_values = np.array(phi_values)
#
#     print(f"a values: {a_values}")
#     print(f"phi values (in radians): {phi_values}")
#     print(f"phi values (in degrees): {np.degrees(phi_values)}")


# ======================================================================================================================
# This section is to store the function that will be used in the
# BEM code which is developed by myself!!!!!
# ======================================================================================================================

def convergence_check(old_values, new_values, threshold=1e-6):
    """
    :param old_values:
    :param new_values:
    :param threshold:
    :return: error between two iterations
    """
    return np.max(np.abs(old_values - new_values)) < threshold


def a_loop(a, a_prime, prop_def, geom_data, loss_model):
    # TODO: change r_station to r_avg and phi_avg!!!!!!!!!
    """
    :param prop_def: Definition of flight conditions
    :param geom_data: Geometry of the Propeller
    :param loss_model: Tip loss model
    :param a: a from last step
    :param a_prime: a' from last step
    :return:
    """
    # Get the absolute position of each section
    r_station = []
    for i in range(len(geom_data)):
        r_station.append(prop_def.tip_radius * geom_data[i, 0])
    r_station = np.asarray(r_station)

    # PHI in radians
    Phi = np.arctan((prop_def.Vinf * (1 + a)) / (prop_def.omega * r_station * (1 - a_prime)))

    Alpha = []
    for i in range(len(geom_data)):
        Alpha.append(geom_data[i, 3] - np.degrees(Phi[i]))
    Alpha = np.asarray(Alpha)

    Cl = np.interp(Alpha, prop_def.airfoil_polar.alpha, prop_def.airfoil_polar.CL)
    Cd = np.interp(Alpha, prop_def.airfoil_polar.alpha, prop_def.airfoil_polar.CD)

    # Prandtl-Glauert compressibility factor
    # local_mach = prop_def.local_v / 340
    # local_mach_corr = 1 / np.sqrt(1 - local_mach**2)
    #
    # Cl = Cl * local_mach_corr

    # Cl correction for rotating blades stalled!! (alpha outside of polar)
    # indices = np.where((Alpha < -9) | (Alpha > 9))[0]

    Cl_pot = np.interp(Alpha, prop_def.airfoil_polar.alpha, prop_def.airfoil_polar.CL_pot)
    # Cl = Cl + (prop_def.geometry.r_R *
    #            np.tanh(
    #                (3.1 * prop_def.omega *
    #                 prop_def.geometry.r * prop_def.geometry.c_R) /
    #                (2 * prop_def.Vinf))
    #            *
    #            (Cl_pot - Cl)
    #            )

    # Snel
    Cl = Cl + 3.1 * (Cl_pot - Cl) * (prop_def.geometry.c_R ** 2)

    # Cl[indices] = Cl_rot[indices]

    Cn = []
    Ct = []
    for i in range(len(Cl)):
        # Axial Direction
        # !!!!Coordinate transformation fault found!!!!
        Cn.append(Cl[i] * np.cos(Phi[i])
                  -
                  Cd[i] * np.sin(Phi[i])
                  )

        # Tangential Direction
        Ct.append(Cl[i] * np.sin(Phi[i])
                  +
                  Cd[i] * np.cos(Phi[i])
                  )

    Cn = np.asarray(Cn)
    Ct = np.asarray(Ct)

    sigma_r = []
    for i in range(len(geom_data)):
        sigma_r.append(
            (prop_def.B * geom_data[i, 1] * prop_def.tip_radius)
            /
            (2 * np.pi * r_station[i])
        )
    sigma_r = np.asarray(sigma_r)

    # TODO: TIP LOSS Factor to be added (Different methods) ✔
    if loss_model == 'A&L':
        f = (prop_def.B / 2) * ((prop_def.tip_radius - r_station) / (r_station * np.sin(Phi)))
        F = (2 / np.pi) * np.arccos(np.exp(-f))

    elif loss_model == 'Veldhuis':
        s = (2 * np.pi * prop_def.tip_radius / prop_def.B) * np.sin(Phi)
        F = (2 / np.pi) * np.arccos(np.exp(-(np.pi * (prop_def.tip_radius - r_station)) / s))

    elif loss_model == 'Prandtl':
        # Free-tip treatment incorporates Prandtl's averaging factor f
        sfac = np.sqrt(1 + (1 / (prop_def.J ** 2)))
        arg = np.zeros(len(prop_def.geometry.r))
        for i in range(len(prop_def.geometry.r)):
            arg[i] = min(20.0, 0.5 * prop_def.B * (1 - prop_def.geometry.r[i] / prop_def.tip_radius) * sfac)
        ek = np.exp(-arg)
        fk = np.sqrt(1 - ek * ek)
        F = np.arctan2(fk, ek) * 2 / np.pi

    # Calculation of new a and a' values

    # if loss_model == 'Veldhuis':
    #     a_new = 1 / (((4 * F * (np.sin(Phi) ** 2)) / (sigma_r * Cn)) - 1)
    #     a_prime_new = 1 / (((4 * F * np.sin(Phi) * np.cos(Phi)) / (sigma_r * Ct)) + 1)
    #
    # elif loss_model == 'A&L':
    #     K = Cn / (4 * (np.sin(Phi) ** 2))
    #     K_prime = Ct / (4 * np.sin(Phi) * np.cos(Phi))
    #     a_new = (sigma_r * K) / (F - sigma_r * K)
    #     a_prime_new = (sigma_r * K_prime) / (F + sigma_r * K_prime)

    # The Code is an improved code for improving convergence
    # Characteristics using damping methods alpha=0.5
    if loss_model == 'Veldhuis':
        a_new_computed = 1 / (((4 * F * np.sin(Phi) ** 2) / (sigma_r * Cn)) - 1)
        a_prime_new_computed = 1 / (((4 * F * np.sin(Phi) * np.cos(Phi)) / (sigma_r * Ct)) + 1)

    elif loss_model == 'A&L':
        K = Cn / (4 * (np.sin(Phi) ** 2))
        K_prime = Ct / (4 * np.sin(Phi) * np.cos(Phi))
        a_new_computed = (sigma_r * K) / (F - sigma_r * K)
        a_prime_new_computed = (sigma_r * K_prime) / (F + sigma_r * K_prime)

    elif loss_model == 'Prandtl':
        a_new_computed = sigma_r * Cn / (4 * F * np.sin(Phi)**2 + sigma_r * Cn)
        a_prime_new_computed = sigma_r * Ct / (4 * F * np.sin(Phi) * np.cos(Phi) - sigma_r * Ct)

    # Applying damping to the induction factor updates
    alpha = 0.3
    a_new = (1 - alpha) * a + alpha * a_new_computed
    a_prime_new = (1 - alpha) * a_prime + alpha * a_prime_new_computed

    return a_new, a_prime_new, Cl, Cd, F


def r_cl_plot(r, cl, xr):
    """
    :param r: r Position from my BEM solver
    :param cl: Cl results from my BEM solver
    :param xr: Result Class from XRotor results
    :return: Plot
    """
    plt.figure(figsize=(10, 10))
    #
    plt.plot(r, cl, '-o', label='My BEM Solver')

    # From XRotor Results
    r_xrotor = xr.station_conditions[0] * xr.case.disk.blade.geometry.r_tip
    Cl_xrotor = xr.station_conditions[3]
    plt.plot(r_xrotor, Cl_xrotor, '-x', label='XRotor Results')

    # Add title and label
    plt.title(f'r-Cl plot')
    plt.xlabel('r Station')
    plt.ylabel('Cl')

    # Setting of plot
    plt.grid(True)
    plt.legend()

    file_path = "./bem_solver/xrotor_mybem/r-Cl.png"
    plt.savefig(file_path, dpi=600)

    plt.show()


def r_cd_plot(r, cd, xr):
    """
    :param r: r Position from my BEM solver
    :param cd: Cd results from my BEM solver
    :param xr: Result Class from XRotor results
    :return: Plot
    """
    plt.figure(figsize=(10, 10))
    #
    plt.plot(r, cd, '-o', label='My BEM Solver')

    # From XRotor Results
    r_xrotor = xr.station_conditions[0] * xr.case.disk.blade.geometry.r_tip
    Cd_xrotor = xr.station_conditions[4]
    plt.plot(r_xrotor, Cd_xrotor, '-x', label='XRotor Results')

    # Add title and label
    plt.title(f'r-Cd plot')
    plt.xlabel('r Station')
    plt.ylabel('Cd')

    # Setting of plot
    plt.grid(True)
    plt.legend()

    file_path = "./bem_solver/xrotor_mybem/r-Cd.png"
    plt.savefig(file_path, dpi=600)

    plt.show()


def J_Ct_plot(df_xrotor, df2_mysolver):
    xrotor_ct = df_xrotor['Ct'].values
    xrotor_ct_plus5 = 1.05 * xrotor_ct
    xrotor_ct_minus5 = 0.95 * xrotor_ct

    plt.plot(df2_mysolver['J'].values, df2_mysolver['Ct'].values,
             marker='o', label='My BEM solver Results')
    plt.plot(df_xrotor['J'].values, df_xrotor['Ct'].values,
             marker='x', label='XRotor Results')

    plt.plot(df_xrotor['J'].values, xrotor_ct_plus5, 'g--', label='5% error line')
    plt.plot(df_xrotor['J'].values, xrotor_ct_minus5, 'g--')

    plt.title('J vs Ct')
    plt.xlabel('J')
    plt.ylabel('Ct')
    plt.legend()
    plt.grid(True)

    file_path = "./bem_solver/xrotor_mybem/J-Ct.png"
    plt.savefig(file_path, dpi=600)

    plt.show()


def J_Cp_plot(df_xrotor, df2_mysolver):
    xrotor_cp = df_xrotor['Cp'].values
    xrotor_ct_plus5 = 1.05 * xrotor_cp
    xrotor_ct_minus5 = 0.95 * xrotor_cp

    plt.plot(df2_mysolver['J'].values, df2_mysolver['Cp'].values,
             marker='o', label='My BEM solver Results')
    plt.plot(df_xrotor['J'].values, df_xrotor['Cp'].values,
             marker='x', label='XRotor Results')

    plt.plot(df_xrotor['J'].values, xrotor_ct_plus5, 'g--', label='5% error line')
    plt.plot(df_xrotor['J'].values, xrotor_ct_minus5, 'g--')

    plt.title('J vs Cp')
    plt.xlabel('J')
    plt.ylabel('Cp')
    plt.legend()
    plt.grid(True)

    file_path = "./bem_solver/xrotor_mybem/J-Cp.png"
    plt.savefig(file_path, dpi=600)

    plt.show()


def a_history_plot(array):
    plt.figure(figsize=(12, 6))

    for row in array:
        plt.plot(row)
        plt.pause(0.01)

    plt.title("Plotting 100x34 Array Row by Row")
    plt.xlabel("Column Index")
    plt.ylabel("Value")
    plt.show()


def cl_history_plot(array):
    plt.figure(figsize=(12, 6))

    for row in array:
        plt.plot(row)

        plt.title("Cl history output")
        plt.xlabel("number of position")
        plt.ylabel("Cl history")
        plt.grid(True)

        plt.pause(0.1)

    plt.show()


def cd_history_plot(array):
    plt.figure(figsize=(12, 6))

    for row in array:
        plt.plot(row)
        plt.pause(0.05)

    plt.title("Plotting 100x34 Array Row by Row")
    plt.xlabel("Column Index")
    plt.ylabel("Value")

    plt.show()


def va_vt_plot_xr(xrotor):
    vt_blade = xrotor.station_conditions[6]
    va_blade = xrotor.station_conditions[7]
    vt_slip = xrotor.station_conditions[8]
    va_slip = xrotor.station_conditions[9]

    r_R_station = xrotor.station_conditions[0]

    plt.figure(figsize=(10, 6))

    plt.plot(r_R_station, va_slip, marker='o', label='Va')
    plt.plot(r_R_station, vt_slip, marker='x', label='Vt')

    plt.title("Va, Vt slipstream distribution XRotor")
    plt.xlabel("r/R [-]")
    plt.ylabel("V [m/s]")

    plt.xlim(0.0, 1.2)
    plt.ylim(0.0, 9)

    plt.legend()
    plt.grid(True)

    file_path = "./bem_solver/xrotor_mybem/xrotor-Va-Vt-slip.png"
    plt.savefig(file_path, dpi=600)

    plt.figure(figsize=(10, 6))

    plt.plot(r_R_station, va_blade*142, marker='o', label='Va')
    plt.plot(r_R_station, vt_blade*142, marker='x', label='Vt')

    plt.title("Va, Vt on blade distribution XRotor")
    plt.xlabel("r/R [-]")
    plt.ylabel("V [m/s]")

    plt.xlim(0.0, 1.2)
    plt.ylim(0.0, 9)

    plt.legend()
    plt.grid(True)

    file_path = "./bem_solver/xrotor_mybem/xrotor-Va-Vt-blade.png"
    plt.savefig(file_path, dpi=600)

    # plt.show()


def va_vt_plot_bem(prop):
    a = prop.Result_BEM.a
    va_blade = a * prop.Vinf
    vt_blade = 2 * prop.geometry.r_R * prop.omega * prop.Result_BEM.a_prime

    # Calculation of slipstream velocity based on induced velocity on blades
    blds = prop.B
    pi = math.pi
    xi = prop.geometry.r_R
    vind = vt_blade
    n = xi.shape[0]

    # Initialize vind_gam matrix
    vind_gam = np.zeros(n)
    for i in range(n):
        vind_gam[i] = blds / (2.0 * pi * prop.Result_BEM.F[i] * xi[i])

    # Solve for gam using Numpy's linear algebra solver
    gam = vind[:]/vind_gam

    vt_slip = 2 * prop.Result_BEM.F * vt_blade
    va_slip = 2 * prop.Result_BEM.F * va_blade

    # vt_slip = 2 * blds * gam / (2 * pi * xi)
    # va_slip = vt_slip * xi / (prop.J/np.pi)

    # Plot the induced velocity on blade
    plt.figure(figsize=(10, 6))

    plt.plot(prop.geometry.r_R, va_blade, marker='o', label='Va')
    plt.plot(prop.geometry.r_R, vt_blade, marker='x', label='Vt')

    plt.title("Va, Vt on blade distribution my BEM")
    plt.xlabel("r/R [-]")
    plt.ylabel("V [m/s]")

    plt.xlim(0.0, 1.2)
    plt.ylim(0.0, 9)

    plt.legend()
    plt.grid(True)

    file_path = "./bem_solver/xrotor_mybem/mybem-Va-Vt-blade.png"
    plt.savefig(file_path, dpi=600)

    # Plot the induced velocity in slipstream
    plt.figure(figsize=(10, 6))

    plt.plot(prop.geometry.r_R, va_slip, marker='o', label='Va_new')
    plt.plot(prop.geometry.r_R, vt_slip, marker='x', label='Vt_new')

    plt.title("Va, Vt slipstream distribution my BEM")
    plt.xlabel("r/R [-]")
    plt.ylabel("V [m/s]")

    plt.xlim(0.0, 1.2)
    plt.ylim(0.0, 9)

    plt.legend()
    plt.grid(True)

    file_path = "./bem_solver/xrotor_mybem/mybem-Va-Vt-slip.png"
    plt.savefig(file_path, dpi=600)

    data = np.vstack((prop.geometry.r_R, va_slip, vt_slip)).T

    header_str = "r_norm     va     vt"

    np.savetxt(f"./bem_solver/slipstream/B{prop.B}_vel{prop.Vinf}_rpm{prop.RPM}.txt",
               data, header=header_str, delimiter="\t", comments="", fmt="%.5f")

    plt.show()


# ======================================================================================================================
# This section is used to store all the functions that related
# to PyoptSparse process
# ======================================================================================================================
def variable_change(xdict, xml_path):
    chord_3, twist_3, half_span, tip_x = xdict["xvars"][0], xdict["xvars"][1], xdict["xvars"][2], xdict["xvars"][3]

    with open(xml_path, "r") as fp:
        cpacs_dict = xml.parse(fp.read())

    main_wing = cpacs_dict['cpacs']['vehicles']['aircraft']['model']['wings']['wing'][0]

    main_wing['sections']['section'][2]['transformation']['scaling']['x'] = f'{chord_3}'
    main_wing['sections']['section'][2]['transformation']['rotation']['y'] = f'{twist_3}'
    main_wing['sections']['section'][2]['transformation']['translation']['y'] = f'{half_span}'
    main_wing['sections']['section'][2]['transformation']['translation']['x'] = f'{tip_x}'

    new_xml_content = xmltodict.unparse(cpacs_dict)

    with open(xml_path, "w") as fp:
        fp.write(new_xml_content)


def objective_function(x, cpacs_reference):
    chord_3, twist_3 = x[0], x[1]

    with open(cpacs_reference, "r") as fp:
        cpacs_dict = xml.parse(fp.read())

    main_wing = cpacs_dict['cpacs']['vehicles']['aircraft']['model']['wings']['wing'][0]

    main_wing['sections']['section'][2]['transformation']['scaling']['x'] = f'{chord_3}'
    main_wing['sections']['section'][2]['transformation']['rotation']['y'] = f'{twist_3}'

    new_xml_content = xmltodict.unparse(cpacs_dict)

    with open(cpacs_reference, "w") as fp:
        fp.write(new_xml_content)


    # # Pre-allocate data
    # chord_list = []
    # twist_list = []
    # section_x_list = []
    # section_y_list = []
    # span_list = []
    # sweep_list = []
    #
    # # Read the cpacs ref file
    # cpacs = CPACS(cpacs_reference)
    #
    # # Extract the main Wing data
    # main_wing = cpacs.model['wings']['wing'][0]
    #
    # for i in range(len(main_wing['sections']['section'])):
    #     chord_list.append(float(main_wing['sections']['section'][i]['transformation']['scaling']['x']))
    #     twist_list.append(float(main_wing['sections']['section'][i]['transformation']['rotation']['y']))
    #     section_x_list.append(float(main_wing['sections']['section'][i]['transformation']['translation']['x']))
    #     section_y_list.append(float(main_wing['sections']['section'][i]['transformation']['translation']['y']))
    #
    # chord = np.asarray(chord_list)
    # twist = np.asarray(twist_list)
    # section_x = np.asarray(section_x_list)
    # section_y = np.asarray(section_y_list)
    #
    # for i in range(len(chord) - 1):
    #     span_list.append(section_span := section_y[i+1] - section_y[i])
    #     sweep_list.append((section_x[i+1] - section_x[i]) / section_span)
    #
    # span = np.asarray(span_list)
    # sweep = np.asarray(sweep_list)




# TODO: In future it should be replaced with DLR software to estimate parasite drag
# def parasite_drag(cpacs, operpnt):
#     # Pre-allocate data
#     chord_list = []
#     twist_list = []
#     thick_list = []
#     section_x_list = []
#     section_y_list = []
#
#     # Extract the main Wing data
#     main_wing = cpacs.model['wings']['wing'][0]
#
#     for i in range(len(main_wing['sections']['section'])):
#         chord_list.append(float(main_wing['sections']['section'][i]['transformation']['scaling']['x']))
#         twist_list.append(float(main_wing['sections']['section'][i]['transformation']['rotation']['y']))
#         section_x_list.append(float(main_wing['sections']['section'][i]['transformation']['translation']['x']))
#         section_y_list.append(float(main_wing['sections']['section'][i]['transformation']['translation']['y']))
#
#     chord = np.asarray(chord_list)
#     twist = np.asarray(twist_list)
#     section_x = np.asarray(section_x_list)
#     section_y = np.asarray(section_y_list)
#
#     # T_C max for Do328 at wing root section
#     t_c_max = 0.17305
#
#     mu = 1.81e-5
#     Re = operpnt.rho * operpnt.Vinf * cpacs.ref_c / mu
#     Ma = float(cpacs.aeromap[0]['ns1:specification']['ns1:machNumber'])
#
#     # Cut off reynolds number
#     Re_co = 38 * ((cpacs.ref_c / 1e-5) ** 1.053)
#
#     if Re > Re_co:
#         Re = Re_co
#
#     Cf = 0.455 * ((1 + 0.144 * Ma * Ma) ** -0.65) / (math.log10(Re) ** 2.58)
#
#
#     return Cdo


if __name__ == '__main__':
    oper_point = OperPNT()
    oper_point.beta_70 = 55.31
    oper_point.rho = 1.225
    oper_point.hub_radius = 0.376
    oper_point.tip_radius = 1.88
    # oper_point.RPM_list = list(range(700, 1001, 100))
    oper_point.RPM_list = [800]
    oper_point.Vinf = 142
    oper_point.B = 6

    cpacs_ref = "./LILI/Do328_out/propTrue_RPM800/propTrue_RPM800.xml"
    # optimize_wing()
    # objective_function(cpacs_ref, oper_point)






