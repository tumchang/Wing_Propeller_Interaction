"""
============================================================================
This script stored the classes, functions, methods for the
xfoil --> xrotor --> Lifting Line workflow

main script name: xrotor_liftingline_main

Xfoil: https://web.mit.edu/drela/Public/web/xfoil/
Xrotor: https://web.mit.edu/drela/Public/web/xrotor/
Lifting Line: https://www.dlr.de/as/en/desktopdefault.aspx/tabid-188/379_read-625/
-------------
Author: Chang Xu   TUM   03739064  August.2023
Supervisor: Yiyuan Ma & Alexandros Lessis

Copyright @ Bauhaus Luftfahrt e.V
============================================================================
"""

# Module import
import xmltodict
import math
import xml.etree.ElementTree as ET
from xrotor import XRotor
from xrotor.model import Case
from scipy.optimize import minimize
from pyoptsparse.pyOpt_history import History
from pyoptsparse import SLSQP, NSGA2
from Lifting_Line_Visualization import *
from VSP.cpacs_vsp_wrapper import *


class OperPNT:
    def __init__(self):
        self.beta_70 = None
        self.rho = None
        self.hub_radius = None
        self.tip_radius = None
        self.RPM_list = None
        self.Vinf = None
        self.B = None


class AirfoilPolar:
    """
    get basic data from airfoil polar file generated by Xfoil and store the data
    """

    def __init__(self, polar_file_dir):
        self.airfoil = None
        alpha_list = []
        CL_list = []
        CD_list = []
        CDp_list = []
        CM_list = []
        Top_Xtr_list = []
        Bot_Xtr_list = []

        with open(polar_file_dir, 'r') as file:
            # Read the Airfoil Name
            for line in file:
                if "Calculated polar for:" in line:
                    self.airfoil = line.split(":")[1].strip()

            # Reset the file's pointer to the beginning
            file.seek(0)

            # Skip header lines
            for i in range(12):
                next(file)

            # Process each data line
            for line in file:
                values = line.split()

                alpha_list.append(float(values[0]))
                CL_list.append(float(values[1]))
                CD_list.append(float(values[2]))
                CDp_list.append(float(values[3]))
                CM_list.append(float(values[4]))
                Top_Xtr_list.append(float(values[5]))
                Bot_Xtr_list.append(float(values[6]))

        # Calculate Cl.potential using Cl.p = 2*pi*alpha
        CL_pot_list = []
        for alpha in alpha_list:
            CL_pot_list.append(
                np.radians(alpha) * 2 * np.pi
            )

        # Convert lists to numpy arrays
        self.alpha = np.array(alpha_list)
        self.CL = np.array(CL_list)
        self.CD = np.array(CD_list)
        self.CDp = np.array(CDp_list)
        self.CM = np.array(CM_list)
        self.Top_Xtr = np.array(Top_Xtr_list)
        self.Bot_Xtr = np.array(Bot_Xtr_list)
        self.CL_pot = np.array(CL_pot_list)
        self.alpha_rad = np.radians(self.alpha)

    def get_cl_at_cdmin(self):
        # Polynomial fitting
        z = np.polyfit(self.alpha, self.CD, 2)
        p = np.poly1d(z)

        # Minimize the polynomial to get the angle of attack corresponding to min CD
        alpha_at_cdmin = minimize(p, -10).x[0]  # We assume starting from 0 degree AoA

        # Interpolate to get the corresponding CL
        cl_at_cdmin = np.interp(alpha_at_cdmin, self.alpha, self.CL)

        return cl_at_cdmin

    def get_dCDdCL2(self):
        CL = self.CL
        CD = self.CD

        coeffs = np.polyfit(CL ** 2, CD, 1)

        # The coefficient k is the slope of the line (since it's linear with respect to CL^2)
        k = coeffs[0]

        return k


class PropellerSec:

    def __init__(self):
        self.r_avg = None
        self.dr = None


class ResultBEM:

    def __init__(self):
        self.a = None
        self.a_prime = None
        self.Cl = None
        self.Cd = None
        self.F = None


class PropellerGeom:
    """
    hold the Propeller Geometry Data
    """

    def __init__(self, geomdata):
        self.r_R = geomdata[:, 0]
        self.c_R = geomdata[:, 1]
        self.t_c = geomdata[:, 2]
        self.beta = geomdata[:, 3]
        self.section = PropellerSec()


class Propeller:
    """
    hold the Propeller data such as geometry and the
    airfoil polar data
    """

    def __init__(self, polar_file_dir, geom_dist, oper_pnt, RPM):
        # hold data for the prop operate condition

        self.airfoil_polar = AirfoilPolar(polar_file_dir)
        self.geometry = PropellerGeom(geom_dist)
        self.rho = oper_pnt.rho
        self.hub_radius = oper_pnt.hub_radius
        self.tip_radius = oper_pnt.tip_radius
        self.RPM = RPM
        self.omega = (RPM * 2 * np.pi) / 60
        self.Vinf = oper_pnt.Vinf
        self.B = oper_pnt.B
        self.n = RPM / 60
        self.J = oper_pnt.Vinf / ((RPM / 60) * (2 * oper_pnt.tip_radius))
        self.beta_70 = oper_pnt.beta_70
        self.Result_BEM = ResultBEM()
        self.local_v = None

        self.polar_for_xr = np.column_stack((self.airfoil_polar.alpha, self.airfoil_polar.CL,
                                             self.airfoil_polar.CD, self.airfoil_polar.CM))

    # Generate propeller sections using Geometry defined
    def generate_prop_section(self):
        # Get the absolute chord length and r position propeller sections
        self.geometry.c = self.geometry.c_R * self.tip_radius
        self.geometry.r = self.geometry.r_R * self.tip_radius

        # Calculate the middle point r position for each section
        r_avg = []
        for i in range(len(self.geometry.r_R) - 1):
            r_avg.append(
                (self.geometry.r[i] + self.geometry.r[i + 1]) / 2
            )
        r_avg = np.asarray(r_avg)
        self.geometry.section.r_avg = r_avg

        # Calculate the section length
        dr = []
        for i in range(len(self.geometry.r_R) - 1):
            dr.append(
                self.geometry.r[i + 1] - self.geometry.r[i]
            )
        dr = np.asarray(dr)
        self.geometry.section.dr = dr

        # Get the local speed of each section
        self.local_v = np.sqrt(self.Vinf ** 2 + (self.geometry.r * self.omega) ** 2)

        return

    def calculate_thrust(self):
        # Get the average tip loss factor in one section
        F_avg = []
        for i in range(len(self.Result_BEM.Cl) - 1):
            F_avg.append(
                (self.Result_BEM.F[i] + self.Result_BEM.F[i + 1]) / 2
            )
        F_avg = np.asarray(F_avg)

        # Get the average axial induced speed factor in one section
        a_avg = []
        for i in range(len(self.Result_BEM.Cl) - 1):
            a_avg.append(
                (self.Result_BEM.a[i] + self.Result_BEM.a[i + 1]) / 2
            )
        a_avg = np.asarray(a_avg)

        # Get the average tangential induced speed factor in one section
        a_prime_avg = []
        for i in range(len(self.Result_BEM.Cl) - 1):
            a_prime_avg.append(
                (self.Result_BEM.a_prime[i] + self.Result_BEM.a_prime[i + 1]) / 2
            )
        a_prime_avg = np.asarray(a_prime_avg)

        # Calculation of Thrust dT for each section
        dT = (
                (2 * F_avg * self.rho * self.Vinf * self.Vinf) *
                (a_avg * (1 + a_avg)) *
                (2 * np.pi * self.geometry.section.r_avg) *
                self.geometry.section.dr
        )

        # Total Thrust
        T = sum(dT)

        # Calculation of Ct
        Ct = T / (
                self.rho * (self.n ** 2) * ((self.tip_radius * 2) ** 4)
        )

        # Calculation of Torque dQ for each section
        dQ = (
                2 * F_avg * a_prime_avg *
                (1 + a_avg) * self.rho * self.Vinf *
                self.omega *
                self.geometry.section.r_avg * self.geometry.section.r_avg *
                (2 * np.pi * self.geometry.section.r_avg) *
                self.geometry.section.dr
        )

        # Q = sum(dQ)

        dP = self.omega * dQ

        P = sum(dP)

        Cp = P / (
                self.rho * (self.n ** 3) * ((self.tip_radius * 2) ** 5)
        )

        # Versuch Axial induced Velocity
        # Va = np.sqrt(
        #     (self.Vinf * self.Vinf / 4) +
        #     (dT / 4 * self.rho * np.pi * self.geometry.section.r_avg)
        #              ) - (self.Vinf/2)

        return T, Ct, Cp


# APC 10*7 Propeller
def validation_geomdata_APC107():
    geom_data = np.array([
        # r/R  c/R    t/c     beta
        [0.15, 0.138, 0.03, 37.86],
        [0.20, 0.154, 0.03, 45.82],
        [0.25, 0.175, 0.03, 44.19],
        [0.30, 0.190, 0.03, 38.35],
        [0.35, 0.198, 0.03, 33.64],
        [0.40, 0.202, 0.03, 29.90],
        [0.45, 0.200, 0.03, 27.02],
        [0.50, 0.195, 0.03, 24.67],
        [0.55, 0.186, 0.03, 22.62],
        [0.60, 0.174, 0.03, 20.88],
        [0.65, 0.161, 0.120, 19.36],
        [0.70, 0.145, 0.120, 17.98],
        [0.75, 0.129, 0.120, 16.74],
        [0.80, 0.112, 0.120, 15.79],
        [0.85, 0.096, 0.120, 14.64],
        [0.90, 0.081, 0.120, 13.86],
        [0.95, 0.061, 0.120, 12.72],
        [1.00, 0.040, 0.120, 11.53]
    ])

    # Create the interpolation functions for each column
    func_c_R = interp1d(geom_data[:, 0], geom_data[:, 1], kind='cubic')
    func_t_c = interp1d(geom_data[:, 0], geom_data[:, 2], kind='cubic')
    func_beta = interp1d(geom_data[:, 0], geom_data[:, 3], kind='cubic')

    # Create a denser r/R array. Here, for example, we interpolate at intervals of 0.025 instead of 0.05.
    dense_r_R = np.arange(0.15, 1.0000, 0.01)

    # Use the dense r/R values to get interpolated values for the other columns
    dense_c_R = func_c_R(dense_r_R)
    dense_t_c = func_t_c(dense_r_R)
    dense_beta = func_beta(dense_r_R)

    # Stack them together to get the new denser geom_data
    dense_validation_geomdata = np.column_stack((dense_r_R, dense_c_R, dense_t_c, dense_beta))

    return dense_validation_geomdata


# Propeller 5868-9
def validation_geomdata_58689():
    # geom_data = np.array([
    #     # r/R  c/R    t/c     beta
    #     [0.20, 0.154, 0.030, 65.12-10],
    #     [0.30, 0.190, 0.040, 53.80-10],
    #     [0.40, 0.202, 0.055, 46.66-10],
    #     [0.50, 0.195, 0.060, 41.89-10],
    #     [0.60, 0.174, 0.058, 38.51-10],
    #     [0.70, 0.145, 0.051, 36.01-10],
    #     [0.75, 0.129, 0.050, 35.00-10],
    #     [0.80, 0.112, 0.047, 34.09-10],
    #     [0.90, 0.081, 0.040, 32.58-10],
    #     [1.00, 0.040, 0.030, 31.36-10]
    # ])

    # geom_data = np.array([
    #     # r/R  c/R    t/c     beta
    #     [0.20, 0.080, 0.500, 45.90],
    #     [0.30, 0.106, 0.200, 41.20],
    #     [0.40, 0.138, 0.125, 46.66-10],
    #     [0.50, 0.152, 0.115, 41.89-10],
    #     [0.60, 0.147, 0.100, 38.51-10],
    #     [0.70, 0.131, 0.080, 36.01-10],
    #     [0.75, 0.122, 0.070, 35.00-10],
    #     [0.80, 0.113, 0.060, 34.09-10],
    #     [0.90, 0.090, 0.050, 32.58-10],
    #     [1.00, 0.044, 0.030, 31.36-10]
    # ])

    geom_data = np.array([
        # r/R  c/R    t/c     beta
        [0.20, 0.080, 0.500, 45.90],
        [0.25, 0.089, 0.500, 43.74],
        [0.30, 0.106, 0.200, 41.51],
        [0.40, 0.138, 0.125, 36.59],
        [0.50, 0.152, 0.115, 32.04],
        [0.60, 0.147, 0.100, 28.46],
        [0.70, 0.131, 0.080, 25.93],
        [0.75, 0.122, 0.070, 25],
        [0.80, 0.113, 0.060, 24.19],
        [0.90, 0.090, 0.050, 22.89],
        [1.00, 0.044, 0.030, 21.71]
    ])

    # Create the interpolation functions for each column
    func_c_R = interp1d(geom_data[:, 0], geom_data[:, 1], kind='cubic')
    func_t_c = interp1d(geom_data[:, 0], geom_data[:, 2], kind='cubic')
    func_beta = interp1d(geom_data[:, 0], geom_data[:, 3], kind='cubic')

    # Create a denser r/R array. Here, for example, we interpolate at intervals of 0.025 instead of 0.05.
    dense_r_R = np.arange(0.25, 1.0000, 0.01)

    # Use the dense r/R values to get interpolated values for the other columns
    dense_c_R = func_c_R(dense_r_R)
    dense_t_c = func_t_c(dense_r_R)
    dense_beta = func_beta(dense_r_R)

    # Stack them together to get the new denser geom_data
    dense_validation_geomdata = np.column_stack((dense_r_R, dense_c_R, dense_t_c, dense_beta))

    return dense_validation_geomdata


def geomdata(beta_70=55.31):
    step = 2.21
    geom_data = np.array([
        # r/R     c/R     t/c     beta
        [0.2000, 0.0759, 0.7977, beta_70 + 10 * step],
        [0.2500, 0.0904, 0.5492, beta_70 + 9 * step],
        [0.3000, 0.1062, 0.3635, beta_70 + 8 * step],
        [0.3500, 0.1226, 0.2405, beta_70 + 7 * step],
        [0.4000, 0.1382, 0.1748, beta_70 + 6 * step],
        [0.4500, 0.1480, 0.1366, beta_70 + 5 * step],
        [0.5000, 0.1520, 0.1182, beta_70 + 4 * step],
        [0.5500, 0.1503, 0.1078, beta_70 + 3 * step],
        [0.6000, 0.1461, 0.1015, beta_70 + 2 * step],
        [0.6500, 0.1393, 0.0955, beta_70 + 1 * step],
        [0.7000, 0.1313, 0.0915, beta_70],
        [0.7500, 0.1224, 0.0884, beta_70 - 1 * step],
        [0.8000, 0.1121, 0.0855, beta_70 - 2 * step],
        [0.8500, 0.1010, 0.0839, beta_70 - 3 * step],
        [0.9000, 0.0886, 0.0818, beta_70 - 4 * step],
        [0.9500, 0.0752, 0.0812, beta_70 - 5 * step],
        [1.0000, 0.0652, 0.0800, beta_70 - 6 * step],
    ])

    # Create the interpolation functions for each column
    # func_c_R = interp1d(geom_data[:, 0], geom_data[:, 1], kind='linear', fill_value="extrapolate")
    # func_t_c = interp1d(geom_data[:, 0], geom_data[:, 2], kind='linear', fill_value="extrapolate")
    # func_beta = interp1d(geom_data[:, 0], geom_data[:, 3], kind='linear', fill_value="extrapolate")

    func_c_R = interp1d(geom_data[:, 0], geom_data[:, 1], kind='cubic')
    func_t_c = interp1d(geom_data[:, 0], geom_data[:, 2], kind='cubic')
    func_beta = interp1d(geom_data[:, 0], geom_data[:, 3], kind='cubic')

    # Create a denser r/R array. Here, for example, we interpolate at intervals of 0.025 instead of 0.05.
    dense_r_R = np.arange(0.2000, 1.000, 0.015)

    # Use the dense r/R values to get interpolated values for the other columns
    dense_c_R = func_c_R(dense_r_R)
    dense_t_c = func_t_c(dense_r_R)
    dense_beta = func_beta(dense_r_R)

    # Stack them together to get the new denser geom_data
    dense_geom_data = np.column_stack((dense_r_R, dense_c_R, dense_t_c, dense_beta))

    return dense_geom_data


def case(propeller, geom_data):
    # geom_data = geomdata(beta_70=propeller.beta_70)
    # geom_data = validation_geomdata_58689()

    # geom_data = ten_eight_MLH_geomdata()
    #     np.array([
    #     # r/R     c/R     t/c     beta
    #     [0.2000, 0.0759, 0.7977, 77.5],
    #     [0.2500, 0.0904, 0.5492, 75.28],
    #     [0.3000, 0.1062, 0.3635, 73.06],
    #     [0.3500, 0.1226, 0.2405, 70.84],
    #     [0.4000, 0.1382, 0.1748, 68.63],
    #     [0.4500, 0.1480, 0.1366, 66.41],
    #     [0.5000, 0.1520, 0.1182, 64.19],
    #     [0.5500, 0.1503, 0.1078, 61.97],
    #     [0.6000, 0.1461, 0.1015, 59.75],
    #     [0.6500, 0.1393, 0.0955, 57.53],
    #     [0.7000, 0.1313, 0.0915, 55.31],
    #     [0.7500, 0.1224, 0.0884, 53.09],
    #     [0.8000, 0.1121, 0.0855, 50.88],
    #     [0.8500, 0.1010, 0.0839, 48.66],
    #     [0.9000, 0.0886, 0.0818, 46.44],
    #     [0.9500, 0.0752, 0.0812, 44.22],
    #     [1.000, 0.0652, 0.0800, 42],
    # ])
    # geom_data[:, 3] -= 5

    case_setting = {
        'conditions': {
            # Standard atmosphere at sea level
            'rho': 0.6597,
            'vso': 340,
            'rmu': 1.789e-5,
            'alt': 8000,
            'vel': propeller.Vinf,
            'adv': propeller.J
        },
        'disk': {
            'n_blds': propeller.B,
            'blade': {
                'geometry': {
                    'r_hub': propeller.hub_radius,
                    'r_tip': propeller.tip_radius,
                    'r_wake': 0.0,
                    'rake': 0.0,
                    'radii': geom_data[:, 0],
                    'chord': geom_data[:, 1],
                    'twist': geom_data[:, 3],
                    'ubody': np.zeros_like(geom_data[:, 0])
                },
                'polars': {
                    0.0: propeller.polar_for_xr,
                    # 0.0: np.array([
                    #             # alfa      Cl      CD        Cm
                    #             [-7.750, -0.3714, 0.11498, -0.0175],
                    #             [-7.500, -0.3722, 0.11289, -0.0166],
                    #             [-7.250, -0.3744, 0.11098, -0.0154],
                    #             [-7.000, -0.3641, 0.10791, -0.0177],
                    #             [-6.750, -0.3484, 0.10439, -0.0215],
                    #             [-6.500, -0.3313, 0.10064, -0.0255],
                    #             [-6.250, -0.3123, 0.09680, -0.0299],
                    #             [-6.000, -0.2900, 0.09268, -0.0352],
                    #             [-5.750, -0.2670, 0.08864, -0.0406],
                    #             [-5.500, -0.2474, 0.08485, -0.0449],
                    #             [-5.250, -0.2215, 0.08067, -0.0509],
                    #             [-5.000, -0.1978, 0.07460, -0.0575],
                    #             [-4.750, -0.1810, 0.07037, -0.0607],
                    #             [-4.500, -0.1577, 0.06642, -0.0646],
                    #             [-4.250, -0.1254, 0.06225, -0.0711],
                    #             [-4.000, -0.0901, 0.05807, -0.0784],
                    #             [-3.750, -0.0542, 0.05390, -0.0856],
                    #             [-3.500, -0.0058, 0.04907, -0.0956],
                    #             [-3.250, 0.0675, 0.04220, -0.1114],
                    #             [-3.000, 0.1139, 0.03842, -0.1184],
                    #             [-2.750, 0.1741, 0.03311, -0.1291],
                    #             [-2.500, 0.2365, 0.02805, -0.1387],
                    #             [-2.250, 0.2961, 0.02363, -0.1466],
                    #             [-2.000, 0.3502, 0.02020, -0.1524],
                    #             [-1.750, 0.3943, 0.01825, -0.1556],
                    #             [-1.500, 0.4347, 0.01673, -0.1584],
                    #             [-1.250, 0.4738, 0.01557, -0.1606],
                    #             [-1.000, 0.5130, 0.01473, -0.1630],
                    #             [-0.750, 0.5500, 0.01419, -0.1648],
                    #             [-0.500, 0.5833, 0.01358, -0.1661],
                    #             [-0.250, 0.6218, 0.01277, -0.1690],
                    #             [0.000, 0.6574, 0.01194, -0.1706],
                    #             [0.250, 0.6763, 0.01139, -0.1681],
                    #             [0.500, 0.7124, 0.01121, -0.1696],
                    #             [0.750, 0.7416, 0.01112, -0.1697],
                    #             [1.000, 0.7774, 0.01089, -0.1711],
                    #             [1.250, 0.8061, 0.01080, -0.1711],
                    #             [1.500, 0.8379, 0.01065, -0.1717],
                    #             [1.750, 0.8723, 0.01044, -0.1727],
                    #             [2.000, 0.9092, 0.01021, -0.1743],
                    #             [2.250, 0.9524, 0.00992, -0.1772],
                    #             [2.500, 1.0035, 0.00966, -0.1819],
                    #             [2.750, 1.0510, 0.00960, -0.1857],
                    #             [3.000, 1.0861, 0.00987, -0.1869],
                    #             [3.250, 1.1113, 0.01039, -0.1860],
                    #             [3.500, 1.1313, 0.01107, -0.1841],
                    #             [3.750, 1.1490, 0.01186, -0.1819],
                    #             [4.000, 1.1664, 0.01271, -0.1798],
                    #             [4.250, 1.1846, 0.01358, -0.1780],
                    #             [4.500, 1.2033, 0.01450, -0.1764],
                    #             [4.750, 1.2225, 0.01547, -0.1749],
                    #             [5.000, 1.2423, 0.01645, -0.1736],
                    #             [5.250, 1.2615, 0.01758, -0.1722],
                    #             [5.500, 1.2809, 0.01874, -0.1709],
                    #             [5.750, 1.2977, 0.02036, -0.1691],
                    #             [6.000, 1.3163, 0.02187, -0.1672],
                    #             [6.250, 1.3359, 0.02316, -0.1654],
                    #             [6.500, 1.3540, 0.02469, -0.1634],
                    #             [6.750, 1.3711, 0.02649, -0.1612],
                    #             [7.000, 1.3883, 0.02859, -0.1590],
                    #             [7.250, 1.4067, 0.03102, -0.1570],
                    #             [7.500, 1.4260, 0.03385, -0.1552],
                    #         ]),

                }
            }
        },
        'settings': {
            'free': True, 'duct': False, 'wind': False
        }
    }

    return case_setting


def operate_xrotor(cases, RPM):
    xr = XRotor()
    # xr.vrtx = True
    xr.use_compr_corr = True
    xr.max_iter = 100
    xr.case = Case.from_dict(cases)
    xr.save_propeller_geometry()

    xr.operate(rpm=RPM)

    xr.print_case()

    return xr


def vput_xr(xr, rpm, print_flag=False):
    """
    This function is used for extracting slip stream output of XROTOR results
    :param print_flag: flag to save the data to a txt file
    :param rpm: RPM
    :param xr: xrotor class
    :return: TXT file under X_ROTOR directory, slipstream data

    """
    r_norm = xr.station_conditions[0]
    vt = xr.station_conditions[8]
    va = xr.station_conditions[9]

    data = np.vstack((r_norm, va, vt)).T

    header_str = "r_norm     va     vt"
    if print_flag:
        np.savetxt(f"./X_ROTOR/B{xr.case.disk.n_blds}_vel{xr.case.conditions.vel}_rpm{rpm}.txt",
                   data, header=header_str, delimiter="\t", comments="", fmt="%.5f")

    return data


def xr_postprocess(xr):
    """
    This function is used for calculating Section parameters
    such as a a' F, based on Xrotor Cl,Cd value

    :param xr:
    :return:
    """
    # TODO:  Project not completed!!!!!!!!!!!
    # Get the local AOA from Cl values from Xrotor results
    local_alpha = np.interp(xr.station_conditions[3],
                            xr.case.disk.blade.polardata[:, 1],
                            xr.case.disk.blade.polardata[:, 0]
                            )

    # Get the local twist
    func_r_twist = interp1d(xr.case.disk.blade.geomdata[0, :],
                            xr.case.disk.blade.geomdata[2, :],
                            kind='cubic',
                            fill_value="extrapolate")

    r_R = xr.station_conditions[0]
    local_twist = func_r_twist(r_R)

    # Get the local phi [deg]
    local_phi_deg = local_twist - local_alpha
    # Change to radians
    local_phi = np.radians(local_phi_deg)

    # Calculation of Cn and Ct
    Cn_xr = (xr.station_conditions[3] * np.cos(local_phi)
             -
             xr.station_conditions[4] * np.sin(local_phi)
             )

    # Tangential Direction
    Ct_xr = (xr.station_conditions[3] * np.sin(local_phi)
             +
             xr.station_conditions[4] * np.cos(local_phi)
             )

    # Calculation of Tip loss factor F
    # TODO: do research of the Tip loss model used by XRotor
    # Ref = E.E. Larrabee. Practical Design of Minimum Induced Loss Propellers. SAE Technical Paper, 1979.
    f = (
            (xr.case.disk.n_blds / 2) *
            ((xr.case.conditions.adv ** 2 + 1) ** 0.5) / xr.case.conditions.adv *
            (1 - xr.station_conditions[0])
    )

    F = (2 / np.pi) * np.arccos(np.exp(-f))

    # Calculation of a and a'
    # Get local chord length
    func_c_r = interp1d(xr.case.disk.blade.geomdata[0, :],
                        xr.case.disk.blade.geomdata[1, :],
                        kind='cubic',
                        fill_value="extrapolate")

    local_chord = func_c_r(xr.station_conditions[0])

    sigma_r_xr = (
            (xr.case.disk.n_blds * local_chord * xr.case.disk.blade.geometry.r_tip)
            /
            (2 * np.pi * (xr.station_conditions[0] * xr.case.disk.blade.geometry.r_tip))
    )

    a_xr = 1 / (((4 * F * np.sin(local_phi) ** 2) / (sigma_r_xr * Cn_xr)) - 1)
    a_prime_xr = 1 / (((4 * F * np.sin(local_phi) * np.cos(local_phi)) / (sigma_r_xr * Ct_xr)) + 1)

    # Calculation of dr
    dr_R_xr = [xr.station_conditions[0][0] - xr.case.disk.blade.geomdata[0, 0]]

    for i in range(len(xr.station_conditions[0]) - 1):
        dr_R_xr.append(xr.station_conditions[0][i + 1]
                       -
                       xr.station_conditions[0][i]
                       )
    dr_R_xr = np.array(dr_R_xr)

    dr_xr = dr_R_xr * xr.case.disk.blade.geometry.r_tip

    # Calculation of dT
    dT_xr = (
            (2 * F * xr.case.conditions.rho) *
            (xr.case.conditions.vel * xr.case.conditions.vel) *
            a_xr * (1 - a_xr) *
            2 * np.pi *
            (xr.station_conditions[0] * xr.case.disk.blade.geometry.r_tip) *
            dr_xr
    )

    T_xr = sum(dT_xr)

    return T_xr


def slipstream_normalize(slip, xr):
    slip_norm = slip.copy()
    slip_norm[:, 1:] = slip_norm[:, 1:] / xr.case.conditions.vel

    return slip_norm


def calc_dev_coeff(oper_pnt, dist):

    kd = 1 + dist/(np.sqrt(dist**2 + oper_pnt.tip_radius**2))

    return kd


def add_slipstream(cpacs_ref, slipstream, RPM, opt_method, prop_flag=True):
    """
    :param RPM:
    :param prop_flag: Turn on or Turn off Propeller rotation
    :param cpacs_ref: CPACS reference file
    :param slipstream: slipstream from XRotor results
    :return:
    """
    if not prop_flag:
        RPM = 0

    # Read the CPACS Reference XML file
    tree = ET.parse(cpacs_ref)
    root = tree.getroot()

    # Define the namespace in order to find the Velocity Field
    namespace = {"ll": "http://www.cpacs.de/liftingLine"}

    # Get the name of aircraft for naming proposes
    for elem in root.findall(".//header/name", namespaces=namespace):
        aircraft_name = elem.text

    # Turn on or turn off propeller Module
    for elem in root.findall(".//ll:usePropModule", namespaces=namespace):
        if prop_flag:
            elem.text = 'true'
        else:
            elem.text = 'false'

    # R_station to be interpolated
    r_lili = np.linspace(slipstream[0, 0], slipstream[-1, 0], 20)

    # Get the number of Angles
    for elem in root.findall(".//ll:numberOfAngles", namespaces=namespace):
        angle_num = int(elem.text)

    # Change the number of r stations to match input slipstream
    # There is a max r station restriction in LILI( [1, 21] ) !!!!!!!!!!!
    # !!!! Interpolation needed !!!!
    for elem in root.findall(".//ll:numberOfRelativeRadii", namespaces=namespace):
        elem.text = str(r_num := 20)

    # Add relative r stations
    for elem in root.findall(".//ll:relativeRadii", namespaces=namespace):
        r_station = np.repeat(r_lili.reshape(-1, 1), angle_num, axis=1)
        r_station = r_station.T.flatten()
        r_station_str = ';'.join(map(str, r_station))  # change to str, use ; as divider
        elem.text = r_station_str

    # Add angles
    for elem in root.findall(".//ll:angles", namespaces=namespace):
        angle = np.linspace(0, 360, angle_num + 1)
        angle = angle[:-1]
        angle = np.repeat(angle.reshape(-1, 1), r_num, axis=1)
        angle = angle.flatten()
        angle_str = ';'.join(map(str, angle))
        elem.text = angle_str

    # Add axial induced speed
    for elem in root.findall(".//ll:relativeAxialFlowSpeeds", namespaces=namespace):
        axial_interp = np.interp(r_lili, slipstream[:, 0], slipstream[:, 1])
        axial = np.repeat(axial_interp.reshape(-1, 1),
                          angle_num, axis=1)
        axial = axial.T.flatten()
        axial_str = ';'.join(map(str, axial))  # change to str, use ; as divider
        elem.text = axial_str

    # Add tangential induced Speed
    for elem in root.findall(".//ll:relativeTangentialFlowSpeeds", namespaces=namespace):
        tangential_interp = np.interp(r_lili, slipstream[:, 0], slipstream[:, 2])
        tangential = np.repeat(tangential_interp.reshape(-1, 1),
                               angle_num, axis=1)
        tangential = tangential.T.flatten()
        tangential_str = ';'.join(map(str, tangential))
        elem.text = tangential_str

    # for elem in root.findall(".//ll:chordwise", namespaces=namespace):
    #     text = elem

    # Write the modified xml
    write_path = f'./LILI/{aircraft_name}/prop{prop_flag}_RPM{RPM}_{opt_method}'
    # write_path = f'./LILI/{aircraft_name}/prop{prop_flag}_RPM{RPM}'
    # Check if the directory exists or not
    if os.path.exists(write_path):
        if prop_flag:
            xml_path = write_path + f'/prop{prop_flag}_RPM{RPM}.xml'
            tree.write(xml_path)
        else:
            xml_path = write_path + f'/propoff.xml'
            tree.write(xml_path)
    else:
        os.makedirs(write_path)
        if prop_flag:
            xml_path = write_path + f'/prop{prop_flag}_RPM{RPM}.xml'
            tree.write(xml_path)
        else:
            xml_path = write_path + f'/propoff.xml'
            tree.write(xml_path)

    print(f'New {aircraft_name} XML file for LILI Analysis created')

    return xml_path


def run_lili(lili_exe_path, xml_path):
    # Get the folder where the xml file is stored
    xml_dir = os.path.dirname(xml_path)

    # Start the lili.exe without blocking and set up communication pipes
    process = subprocess.Popen(lili_exe_path,
                               stdin=subprocess.PIPE,
                               stdout=subprocess.PIPE,
                               stderr=subprocess.PIPE,
                               text=True)

    # Specify the cpacs input file directory
    process.stdin.write(f"{xml_path}\n")
    process.stdin.flush()
    time.sleep(0.5)  # adjust this delay as needed

    process.stdin.write("output\n")
    process.stdin.flush()
    time.sleep(0.5)

    # Close stdin when done sending commands
    process.stdin.close()

    # Capture output if needed
    output = process.stdout.read()
    print(output)

    # Ensure the process finishes
    process.wait()

    # Copy the LILI ReturnDirectory folder to the xml_dir
    # If destination exists, remove it
    if os.path.exists(xml_dir + '/ReturnDirectory'):
        shutil.rmtree(xml_dir + '/ReturnDirectory')

    shutil.move('./ReturnDirectory', xml_dir)

    return xml_dir


def lili_visualization(xml_dir, save_plot=False):
    aircraft_name = "CPACS4LILI_LILI-Config_1"

    # Get the Overall Lift to Drag ratio

    tecplot_dir = xml_dir + '/ReturnDirectory/CPACS4LILI_LILI-Config_1.lili.V3.1/export/tecplot'
    # total_tecplot_dir = xml_dir + '/ReturnDirectory'

    # geom_secs = parse_attributes(tecplot_dir, aircraft_name)
    distribution, distribution_dict = parse_distribution(tecplot_dir, aircraft_name)
    total_distribution = parse_total_dist(tecplot_dir)
    total_coeff = parse_distribution(tecplot_dir, aircraft_name, parse_total=True)

    CD = float(total_distribution[0]['CFX_FROM_CDI'])
    CL = float(total_distribution[0]['CFZ'])

    # ==================================================================================================================
    # This part is used to getting the lift distribution and Dimensionless lateral coordinate of the centre of pressure
    # ==================================================================================================================
    Cl = np.asarray(distribution['CFZ'].iloc[:34])
    Y = np.asarray(distribution['Y'].iloc[:34])

    M_total = sum(Cl * Y)
    eta_y = M_total / (np.sum(Cl)*total_distribution[0]['REF_SPAN'].iloc[0]/2)

    # fig1 = panel_dist_plot(distribution_dict, "CFZ", geom_secs,
    #                        3, mesh_flag=False)
    #
    # fig2, df_cl = cl_distribution_2d(total_distribution)
    # fig3, df_Fz = lift_distribution_2d(total_distribution)
    #
    # # Save the cl and Lift distribution to csv
    # df_cl.to_csv(xml_dir + '/cl_dist.csv', index=False)
    # df_Fz.to_csv(xml_dir + '/Fz_dist.csv', index=False)
    #
    # # Save the plot if necessary
    # if save_plot:
    #     dpi = 600
    #
    #     # List of desired view angles (elev, azim)
    #     view_angles = [(30, -135), (0, 180)]  # Example angles
    #     ax1 = fig1.axes[0]  # assuming there's only one axis in fig1
    #
    #     for elev, azim in view_angles:
    #         ax1.view_init(elev=elev, azim=azim)
    #         filename = panel_dist_plot_{elev}_{azim}.png'
    #         fig1.savefig(os.path.join(xml_dir, filename), dpi=dpi)
    #
    #     fig2.savefig(os.path.join(xml_dir, 'cl_distribution.png'), dpi=dpi)
    #     fig3.savefig(os.path.join(xml_dir, 'lift_distribution.png'), dpi=dpi)

    # Show all the figures
    # plt.show()

    return CL, CD, total_coeff[0], eta_y


# def a_phi_equations(vars, cl_val, cd_val):
#     a, phi = vars
#     eq1 = 4 * a * (1 + a) * np.cos(phi) - cl_val
#     eq2 = 4 * a * (1 + a) * np.sin(phi) - cd_val
#     return [eq1, eq2]
#
#
# def solve_a_phi(xr):
#     cl_array = xr.station_conditions[3]  # CL values from Xrotor
#     cd_array = xr.station_conditions[4]  # CD values from Xrotor
#
#     # Initial guesses for a and phi
#     a_guess = 0.6
#     phi_guess = np.pi / 2
#
#     # Iterate through arrays and solve the system for each pair
#     a_values = []
#     phi_values = []
#
#     for cl_val, cd_val in zip(cl_array, cd_array):
#         a, phi = fsolve(a_phi_equations, (0.6, phi_guess), args=(cl_val, cd_val))
#         a_values.append(a)
#         phi_values.append(phi)
#
#     # Convert results to numpy arrays
#     a_values = np.array(a_values)
#     phi_values = np.array(phi_values)
#
#     print(f"a values: {a_values}")
#     print(f"phi values (in radians): {phi_values}")
#     print(f"phi values (in degrees): {np.degrees(phi_values)}")


# ======================================================================================================================
# This section is to store the function that will be used in the
# BEM code which is developed by myself!!!!!
# ======================================================================================================================

def convergence_check(old_values, new_values, threshold=1e-6):
    """
    :param old_values:
    :param new_values:
    :param threshold:
    :return: error between two iterations
    """
    return np.max(np.abs(old_values - new_values)) < threshold


def a_loop(a, a_prime, prop_def, geom_data, loss_model):
    # TODO: change r_station to r_avg and phi_avg!!!!!!!!!
    """
    :param prop_def: Definition of flight conditions
    :param geom_data: Geometry of the Propeller
    :param loss_model: Tip loss model
    :param a: a from last step
    :param a_prime: a' from last step
    :return:
    """
    # Get the absolute position of each section
    r_station = []
    for i in range(len(geom_data)):
        r_station.append(prop_def.tip_radius * geom_data[i, 0])
    r_station = np.asarray(r_station)

    # PHI in radians
    Phi = np.arctan((prop_def.Vinf * (1 + a)) / (prop_def.omega * r_station * (1 - a_prime)))

    Alpha = []
    for i in range(len(geom_data)):
        Alpha.append(geom_data[i, 3] - np.degrees(Phi[i]))
    Alpha = np.asarray(Alpha)

    Cl = np.interp(Alpha, prop_def.airfoil_polar.alpha, prop_def.airfoil_polar.CL)
    Cd = np.interp(Alpha, prop_def.airfoil_polar.alpha, prop_def.airfoil_polar.CD)

    # Prandtl-Glauert compressibility factor
    # local_mach = prop_def.local_v / 340
    # local_mach_corr = 1 / np.sqrt(1 - local_mach**2)
    #
    # Cl = Cl * local_mach_corr

    # Cl correction for rotating blades stalled!! (alpha outside of polar)
    # indices = np.where((Alpha < -9) | (Alpha > 9))[0]

    Cl_pot = np.interp(Alpha, prop_def.airfoil_polar.alpha, prop_def.airfoil_polar.CL_pot)
    # Cl = Cl + (prop_def.geometry.r_R *
    #            np.tanh(
    #                (3.1 * prop_def.omega *
    #                 prop_def.geometry.r * prop_def.geometry.c_R) /
    #                (2 * prop_def.Vinf))
    #            *
    #            (Cl_pot - Cl)
    #            )

    # Snel
    Cl = Cl + 3.1 * (Cl_pot - Cl) * (prop_def.geometry.c_R ** 2)

    # Cl[indices] = Cl_rot[indices]

    Cn = []
    Ct = []
    for i in range(len(Cl)):
        # Axial Direction
        # !!!!Coordinate transformation fault found!!!!
        Cn.append(Cl[i] * np.cos(Phi[i])
                  -
                  Cd[i] * np.sin(Phi[i])
                  )

        # Tangential Direction
        Ct.append(Cl[i] * np.sin(Phi[i])
                  +
                  Cd[i] * np.cos(Phi[i])
                  )

    Cn = np.asarray(Cn)
    Ct = np.asarray(Ct)

    sigma_r = []
    for i in range(len(geom_data)):
        sigma_r.append(
            (prop_def.B * geom_data[i, 1] * prop_def.tip_radius)
            /
            (2 * np.pi * r_station[i])
        )
    sigma_r = np.asarray(sigma_r)

    # TODO: TIP LOSS Factor to be added (Different methods) ✔
    if loss_model == 'A&L':
        f = (prop_def.B / 2) * ((prop_def.tip_radius - r_station) / (r_station * np.sin(Phi)))
        F = (2 / np.pi) * np.arccos(np.exp(-f))

    elif loss_model == 'Veldhuis':
        s = (2 * np.pi * prop_def.tip_radius / prop_def.B) * np.sin(Phi)
        F = (2 / np.pi) * np.arccos(np.exp(-(np.pi * (prop_def.tip_radius - r_station)) / s))

    elif loss_model == 'Prandtl':
        # Free-tip treatment incorporates Prandtl's averaging factor f
        sfac = np.sqrt(1 + (1 / (prop_def.J ** 2)))
        arg = np.zeros(len(prop_def.geometry.r))
        for i in range(len(prop_def.geometry.r)):
            arg[i] = min(20.0, 0.5 * prop_def.B * (1 - prop_def.geometry.r[i] / prop_def.tip_radius) * sfac)
        ek = np.exp(-arg)
        fk = np.sqrt(1 - ek * ek)
        F = np.arctan2(fk, ek) * 2 / np.pi

    # Calculation of new a and a' values

    # if loss_model == 'Veldhuis':
    #     a_new = 1 / (((4 * F * (np.sin(Phi) ** 2)) / (sigma_r * Cn)) - 1)
    #     a_prime_new = 1 / (((4 * F * np.sin(Phi) * np.cos(Phi)) / (sigma_r * Ct)) + 1)
    #
    # elif loss_model == 'A&L':
    #     K = Cn / (4 * (np.sin(Phi) ** 2))
    #     K_prime = Ct / (4 * np.sin(Phi) * np.cos(Phi))
    #     a_new = (sigma_r * K) / (F - sigma_r * K)
    #     a_prime_new = (sigma_r * K_prime) / (F + sigma_r * K_prime)

    # The Code is an improved code for improving convergence
    # Characteristics using damping methods alpha=0.5
    if loss_model == 'Veldhuis':
        a_new_computed = 1 / (((4 * F * np.sin(Phi) ** 2) / (sigma_r * Cn)) - 1)
        a_prime_new_computed = 1 / (((4 * F * np.sin(Phi) * np.cos(Phi)) / (sigma_r * Ct)) + 1)

    elif loss_model == 'A&L':
        K = Cn / (4 * (np.sin(Phi) ** 2))
        K_prime = Ct / (4 * np.sin(Phi) * np.cos(Phi))
        a_new_computed = (sigma_r * K) / (F - sigma_r * K)
        a_prime_new_computed = (sigma_r * K_prime) / (F + sigma_r * K_prime)

    elif loss_model == 'Prandtl':
        a_new_computed = sigma_r * Cn / (4 * F * np.sin(Phi) ** 2 + sigma_r * Cn)
        a_prime_new_computed = sigma_r * Ct / (4 * F * np.sin(Phi) * np.cos(Phi) - sigma_r * Ct)

    # Applying damping to the induction factor updates
    alpha = 0.3
    a_new = (1 - alpha) * a + alpha * a_new_computed
    a_prime_new = (1 - alpha) * a_prime + alpha * a_prime_new_computed

    return a_new, a_prime_new, Cl, Cd, F


def r_cl_plot(r, cl, xr):
    """
    :param r: r Position from my BEM solver
    :param cl: Cl results from my BEM solver
    :param xr: Result Class from XRotor results
    :return: Plot
    """
    plt.figure(figsize=(10, 10))
    #
    plt.plot(r, cl, '-o', label='My BEM Solver')

    # From XRotor Results
    r_xrotor = xr.station_conditions[0] * xr.case.disk.blade.geometry.r_tip
    Cl_xrotor = xr.station_conditions[3]
    plt.plot(r_xrotor, Cl_xrotor, '-x', label='XRotor Results')

    # Add title and label
    plt.title(f'r-Cl plot')
    plt.xlabel('r Station')
    plt.ylabel('Cl')

    # Setting of plot
    plt.grid(True)
    plt.legend()

    file_path = "./bem_solver/xrotor_mybem/r-Cl.png"
    plt.savefig(file_path, dpi=600)

    plt.show()


def r_cd_plot(r, cd, xr):
    """
    :param r: r Position from my BEM solver
    :param cd: Cd results from my BEM solver
    :param xr: Result Class from XRotor results
    :return: Plot
    """
    plt.figure(figsize=(10, 10))
    #
    plt.plot(r, cd, '-o', label='My BEM Solver')

    # From XRotor Results
    r_xrotor = xr.station_conditions[0] * xr.case.disk.blade.geometry.r_tip
    Cd_xrotor = xr.station_conditions[4]
    plt.plot(r_xrotor, Cd_xrotor, '-x', label='XRotor Results')

    # Add title and label
    plt.title(f'r-Cd plot')
    plt.xlabel('r Station')
    plt.ylabel('Cd')

    # Setting of plot
    plt.grid(True)
    plt.legend()

    file_path = "./bem_solver/xrotor_mybem/r-Cd.png"
    plt.savefig(file_path, dpi=600)

    plt.show()


def J_Ct_plot(df_xrotor, df2_mysolver):
    xrotor_ct = df_xrotor['Ct'].values
    xrotor_ct_plus5 = 1.05 * xrotor_ct
    xrotor_ct_minus5 = 0.95 * xrotor_ct

    plt.plot(df2_mysolver['J'].values, df2_mysolver['Ct'].values,
             marker='o', label='My BEM solver Results')
    plt.plot(df_xrotor['J'].values, df_xrotor['Ct'].values,
             marker='x', label='XRotor Results')

    plt.plot(df_xrotor['J'].values, xrotor_ct_plus5, 'g--', label='5% error line')
    plt.plot(df_xrotor['J'].values, xrotor_ct_minus5, 'g--')

    plt.title('J vs Ct')
    plt.xlabel('J')
    plt.ylabel('Ct')
    plt.legend()
    plt.grid(True)

    file_path = "./bem_solver/xrotor_mybem/J-Ct.png"
    plt.savefig(file_path, dpi=600)

    plt.show()


def J_Cp_plot(df_xrotor, df2_mysolver):
    xrotor_cp = df_xrotor['Cp'].values
    xrotor_ct_plus5 = 1.05 * xrotor_cp
    xrotor_ct_minus5 = 0.95 * xrotor_cp

    plt.plot(df2_mysolver['J'].values, df2_mysolver['Cp'].values,
             marker='o', label='My BEM solver Results')
    plt.plot(df_xrotor['J'].values, df_xrotor['Cp'].values,
             marker='x', label='XRotor Results')

    plt.plot(df_xrotor['J'].values, xrotor_ct_plus5, 'g--', label='5% error line')
    plt.plot(df_xrotor['J'].values, xrotor_ct_minus5, 'g--')

    plt.title('J vs Cp')
    plt.xlabel('J')
    plt.ylabel('Cp')
    plt.legend()
    plt.grid(True)

    file_path = "./bem_solver/xrotor_mybem/J-Cp.png"
    plt.savefig(file_path, dpi=600)

    plt.show()


def a_history_plot(array):
    plt.figure(figsize=(12, 6))

    for row in array:
        plt.plot(row)
        plt.pause(0.01)

    plt.title("Plotting 100x34 Array Row by Row")
    plt.xlabel("Column Index")
    plt.ylabel("Value")
    plt.show()


def cl_history_plot(array):
    plt.figure(figsize=(12, 6))

    for row in array:
        plt.plot(row)

        plt.title("Cl history output")
        plt.xlabel("number of position")
        plt.ylabel("Cl history")
        plt.grid(True)

        plt.pause(0.1)

    plt.show()


def cd_history_plot(array):
    plt.figure(figsize=(12, 6))

    for row in array:
        plt.plot(row)
        plt.pause(0.05)

    plt.title("Plotting 100x34 Array Row by Row")
    plt.xlabel("Column Index")
    plt.ylabel("Value")

    plt.show()


def va_vt_plot_xr(xrotor):
    vt_blade = xrotor.station_conditions[6]
    va_blade = xrotor.station_conditions[7]
    vt_slip = xrotor.station_conditions[8]
    va_slip = xrotor.station_conditions[9]

    r_R_station = xrotor.station_conditions[0]

    plt.figure(figsize=(10, 6))

    plt.plot(r_R_station, va_slip, marker='o', label='Va')
    plt.plot(r_R_station, vt_slip, marker='x', label='Vt')

    plt.title("Va, Vt slipstream distribution XRotor")
    plt.xlabel("r/R [-]")
    plt.ylabel("V [m/s]")

    plt.xlim(0.0, 1.2)
    plt.ylim(0.0, 40)

    plt.legend()
    plt.grid(True)

    file_path = "./bem_solver/xrotor_mybem/xrotor-Va-Vt-slip.png"
    plt.savefig(file_path, dpi=600)

    plt.figure(figsize=(10, 6))

    plt.plot(r_R_station, va_blade * 142, marker='o', label='Va')
    plt.plot(r_R_station, vt_blade * 142, marker='x', label='Vt')

    plt.title("Va, Vt on blade distribution XRotor")
    plt.xlabel("r/R [-]")
    plt.ylabel("V [m/s]")

    plt.xlim(0.0, 1.2)
    plt.ylim(0.0, 40)

    plt.legend()
    plt.grid(True)

    file_path = "./bem_solver/xrotor_mybem/xrotor-Va-Vt-blade.png"
    plt.savefig(file_path, dpi=600)

    data = np.vstack((r_R_station, va_slip/51.4096, vt_slip/51.4096)).T

    np.savetxt(f"./VALIDATION/vali_slip.txt", data, fmt="%.5f")

    # plt.show()


def va_vt_plot_bem(prop):
    a = prop.Result_BEM.a
    va_blade = a * prop.Vinf
    vt_blade = prop.geometry.r * prop.omega * prop.Result_BEM.a_prime

    # Calculation of slipstream velocity based on induced velocity on blades
    blds = prop.B
    pi = math.pi
    xi = prop.geometry.r_R
    vind = vt_blade
    n = xi.shape[0]

    # Initialize vind_gam matrix
    vind_gam = np.zeros(n)
    for i in range(n):
        vind_gam[i] = blds / (2.0 * pi * prop.Result_BEM.F[i] * xi[i])

    # Solve for gam using Numpy's linear algebra solver
    gam = vind[:] / vind_gam

    # vt_slip = 2 * prop.Result_BEM.F * vt_blade
    # va_slip = 2 * prop.Result_BEM.F * va_blade

    vt_slip = 2 * blds * gam / (2 * pi * xi)
    va_slip = vt_slip * xi / (prop.J/np.pi)

    # Plot the induced velocity on blade
    plt.figure(figsize=(10, 6))

    plt.plot(prop.geometry.r_R, va_blade, marker='o', label='Va')
    plt.plot(prop.geometry.r_R, vt_blade, marker='x', label='Vt')

    plt.title("Va, Vt on blade distribution my BEM")
    plt.xlabel("r/R [-]")
    plt.ylabel("V [m/s]")

    plt.xlim(0.0, 1.2)
    plt.ylim(0.0, 40)

    plt.legend()
    plt.grid(True)

    file_path = "./bem_solver/xrotor_mybem/mybem-Va-Vt-blade.png"
    plt.savefig(file_path, dpi=600)

    # Plot the induced velocity in slipstream
    plt.figure(figsize=(10, 6))

    plt.plot(prop.geometry.r_R, va_slip, marker='o', label='Va_new')
    plt.plot(prop.geometry.r_R, vt_slip, marker='x', label='Vt_new')

    plt.title("Va, Vt slipstream distribution my BEM")
    plt.xlabel("r/R [-]")
    plt.ylabel("V [m/s]")

    plt.xlim(0.0, 1.2)
    plt.ylim(0.0, 40)

    plt.legend()
    plt.grid(True)

    file_path = "./bem_solver/xrotor_mybem/mybem-Va-Vt-slip.png"
    plt.savefig(file_path, dpi=600)

    data = np.vstack((prop.geometry.r_R, va_slip, vt_slip)).T

    header_str = "r_norm     va     vt"

    np.savetxt(f"./bem_solver/slipstream/B{prop.B}_vel{prop.Vinf}_rpm{prop.RPM}.txt",
               data, header=header_str, delimiter="\t", comments="", fmt="%.5f")

    plt.show()


# ======================================================================================================================
# This section is used to store all the functions that related
# to PyoptSparse process
# ======================================================================================================================
class WingShape:
    def __init__(self, cpacs_init, eta_cp, wing_method):
        self.segment = None
        self.sweep_LE = None
        self.sweep_25 = None
        self.sweep_50 = None
        wing_original_shape_df, original_area, original_AR, origin_lambda = self.get_original_wing(cpacs_init)
        self.section = wing_original_shape_df
        self.b_ref = wing_original_shape_df['tip_y'].iloc[-1]*2
        self.area = original_area
        self.taper_ratio = origin_lambda
        self.AR = original_AR
        self.t_c_root = 0.17305
        self.t_c_tip = 0.13004
        self.ult_load_factor = 3.75
        self.MTOW = 13990
        self.MZFW = 12610 - 3738

        if wing_method == 'Raymer':
            self.wing_weight_est = self.wing_weight_raymer()
        elif wing_method == 'Torenbeek':
            self.wing_weight_est = self.wing_weight_torenbeek(eta_cp)

        self.ZFW_no_wing = 12610 - 3738 - self.wing_weight_est + 1704

    def get_original_wing(self, cpacs_init):
        # Get the section data
        chord = []
        twist = []
        tip_x = []
        tip_y = []

        with open(cpacs_init, "r") as fp:
            cpacs_dict = xml.parse(fp.read())

        main_wing = cpacs_dict['cpacs']['vehicles']['aircraft']['model']['wings']['wing'][0]

        for i in range(len(main_wing['sections']['section'])):
            chord.append(float(main_wing['sections']['section'][i]['transformation']['scaling']['x']))
            twist.append(float(main_wing['sections']['section'][i]['transformation']['rotation']['y']))
            tip_x.append(float(main_wing['sections']['section'][i]['transformation']['translation']['x']))
            tip_y.append(float(main_wing['sections']['section'][i]['transformation']['translation']['y']))

        wing_original_shape_df = pd.DataFrame({
            'chord': chord,
            'twist': twist,
            'tip_x': tip_x,
            'tip_y': tip_y
        })

        # Total parameters
        original_area = (chord[0] + chord[1]) * (tip_y[1] - tip_y[0]) + (chord[1] + chord[2]) * (tip_y[2] - tip_y[1])
        original_AR = (2*tip_y[2])**2 / original_area
        origin_lambda = chord[2]/chord[0]
        sweep_LE = np.arctan(((tip_x[2] + 0.00*chord[2]) - (tip_x[0] + 0.00*chord[0])) / tip_y[2])
        sweep_25 = np.arctan(((tip_x[2] + 0.25*chord[2]) - (tip_x[0] + 0.25*chord[0])) / tip_y[2])
        sweep_50 = np.arctan(((tip_x[2] + 0.50*chord[2]) - (tip_x[0] + 0.50*chord[0])) / tip_y[2])

        self.sweep_LE = sweep_LE
        self.sweep_25 = sweep_25
        self.sweep_50 = sweep_50

        # Get the segment data
        sweep = []
        taper_ratio = []
        for i in range(1, len(tip_x)):
            sweep.append(np.arctan((tip_x[i] - tip_x[i-1]) / (tip_y[i] - tip_y[i-1])))
            taper_ratio.append(chord[i] / chord[i-1])
        sweep = np.asarray(sweep)
        taper_ratio = np.asarray(taper_ratio)

        segment_df = pd.DataFrame({
            'sweep': sweep,
            'taper_ratio': taper_ratio,
        })

        self.segment = segment_df

        return wing_original_shape_df, original_area, original_AR, origin_lambda

    def wing_weight_raymer(self):
        wing_weight_est = (
                0.0051 * (2.205 * self.MTOW * self.ult_load_factor) ** 0.557 * (10.7639104 * self.area)
                ** 0.649 * self.AR ** 0.5 * (self.t_c_root ** -0.4) * (1 + self.taper_ratio) ** 0.1
                * (np.cos(self.sweep_25)) ** -1 * (10.7639104 * 0.1 * self.area) ** 0.1
        )

        return wing_weight_est

    def wing_weight_torenbeek(self, eta_cp):
        # Dimensionless lateral coordinate of the centre of pressure
        eta_cp = eta_cp

        # eta_cp = 1 / (3 * self.ult_load_factor) * ((4 / np.pi) + (self.ult_load_factor - 1)
        #                                            * (1 + 2 * self.taper_ratio) / (1 + self.taper_ratio))

        # for Subsonic AC (0.84 for transonic)
        eta_t = 0.81

        # Structural Wing Span
        b_s = self.b_ref / np.cos(self.sweep_50)

        k_w = 6.67e-3

        # first guess of wing group weight
        W_w = (
                self.MZFW * k_w * (b_s**0.75) * (1 + np.sqrt(self.b_ref/b_s)) * (self.ult_load_factor**0.55)
                * ((b_s/self.t_c_root*self.section['chord'].loc[0])/(self.MZFW/self.area))**0.3
        )

        # Inertia Relief
        R_in_w = W_w/self.MTOW
        # TODO Engine inertia relief and Fuel inertia Relief to be added
        R_in = 1 - R_in_w

        R_cant = b_s / (2 * self.t_c_root * self.section['chord'].loc[0])
        k_mat = 2796  # Specific weight of Al [N/m^3]

        # % Torenbeek, 1992, "Development and application of a comprehensive,
        # design-sensitive weight prediction method for wing structures of transport category aircraft".
        # Equ. 11.79 and following
        k_mat_str = 4 * 10**-5 * (1 + 1.1 * (self.MTOW / 10**6)**(-0.25))

        k_rib = 0.005
        t_ref = 1

        wingbox_weight = (
                0.36 * self.ult_load_factor * R_in * self.MTOW
                * eta_cp * b_s * k_mat_str * ((1.05*R_cant/eta_t)+3.67)
                )
        rib_weight = (
                k_mat * k_rib * self.area * (t_ref + (self.t_c_root*self.section['chord'].loc[0] +
                                                      self.t_c_tip*self.section['chord'].loc[2]) / 2)
        )

        wing_id = wingbox_weight + rib_weight

        return wing_id


def variable_change(xdict, xml_path, origin_df, operpnt):
    chord_3, twist_3, half_span = xdict["chord3"], xdict["twist3"], xdict["half span"]

    with open(xml_path, "r") as fp:
        cpacs_dict = xml.parse(fp.read())

    main_wing = cpacs_dict['cpacs']['vehicles']['aircraft']['model']['wings']['wing'][0]

    main_wing['sections']['section'][2]['transformation']['scaling']['x'] = f'{chord_3}'
    main_wing['sections']['section'][2]['transformation']['rotation']['y'] = f'{twist_3}'
    main_wing['sections']['section'][2]['transformation']['translation']['y'] = f'{half_span}'

    # Get the original Sweep angle
    y_2 = float(main_wing['sections']['section'][2]['transformation']['translation']['y'])
    y_1 = float(main_wing['sections']['section'][1]['transformation']['translation']['y'])
    delta_x = float(main_wing['sections']['section'][2]['transformation']['translation']['x'])

    sweep_init = 0.0764765867750202

    tip_x_3 = np.tan(sweep_init) * (half_span - y_1)

    main_wing['sections']['section'][2]['transformation']['translation']['x'] = f'{tip_x_3}'

    # Change the reference area
    new_area = (
                 (origin_df["chord"][0] + origin_df["chord"][1]) * (origin_df["tip_y"][1] - origin_df["tip_y"][0])
                 + (origin_df["chord"][1] + chord_3) * (half_span - origin_df["tip_y"][1])
                )
    cpacs_dict['cpacs']['vehicles']['aircraft']['model']['reference']['area'] = f'{new_area}'
    # Change of the mean chord length
    l_mac = new_area/(2*half_span)
    cpacs_dict['cpacs']['vehicles']['aircraft']['model']['reference']['length'] = f'{l_mac}'

    # Parasite Calculation part=========================================================================================
    # T_C max for Do328 at wing root section
    t_c_max = 0.17305
    mu = 1.81e-5
    Re = operpnt.rho * operpnt.Vinf * l_mac / mu
    aerocase = cpacs_dict['cpacs']['toolspecific']['tool']['ns1:liftingLine']['ns1:toolInput']['ns1:aeroCases']
    Ma = float(aerocase['ns1:aeroCase']['ns1:specification']['ns1:machNumber'])

    # Cut off reynolds number
    Re_co = 38 * ((l_mac / 1e-5) ** 1.053)

    if Re > Re_co:
        Re = Re_co

    Cf = 0.455 * ((1 + 0.144 * Ma * Ma) ** -0.65) / (np.log10(Re) ** 2.58)

    Fw = (1 + 1.5 * t_c_max + 100 * t_c_max**4) * (1.34 * Ma**0.18)

    Cdo = 2 * Fw * Cf

    new_xml_content = xmltodict.unparse(cpacs_dict)

    print(f"Cdo={Cdo}, new_area={new_area}, l_mac={l_mac}")

    with open(xml_path, "w") as fp:
        fp.write(new_xml_content)

    return Cdo


def history_visualization(his_file, optProb=SLSQP):
    # Variable plot part=========================================================================================
    history = History(his_file, optProb=optProb)
    chord3_his = history.getValues(names='chord3', major=True)['chord3']
    # Locate the deviated value of chord and find it index
    error_index = int(np.where((chord3_his < 0.01) | (chord3_his > 2.21))[0])
    chord3_his = np.delete(chord3_his, error_index)

    twist3_his = history.getValues(names='twist3', major=True)['twist3']
    twist3_his = np.delete(twist3_his, error_index)

    half_span_his = history.getValues(names='half span', major=True)['half span']
    half_span_his = np.delete(half_span_his, error_index)

    fig1, ax1 = plt.subplots(3, 1, figsize=(9, 8))
    fig1.suptitle('Variable History', fontsize=16)

    # Plot chord3 history
    ax1[0].plot(chord3_his, '-o', label='chord3', color='blue')
    ax1[0].axhline(0.442, color='black', linestyle='--', label='lower limit')  # Adding the dashed line
    ax1[0].set_title('chord3')
    ax1[0].set_xlabel('Iteration')
    ax1[0].set_ylabel('chord3 [m]')
    ax1[0].set_ylim([0, 2.21])
    ax1[0].grid(True)
    ax1[0].legend()

    # Plot twist3 history
    ax1[1].plot(twist3_his, '-o', label='twist3', color='green')
    ax1[1].set_title('twist3')
    ax1[1].set_xlabel('Iteration')
    ax1[1].set_ylabel('twist3 [deg]')
    ax1[1].set_ylim([-5, 2])
    ax1[1].grid(True)
    ax1[1].legend()

    # Plot half span history
    ax1[2].plot(half_span_his, '-o', label='half span', color='red')
    ax1[2].set_title('Half Span')
    ax1[2].set_xlabel('Iteration')
    ax1[2].set_ylabel('Half Span [m]')
    ax1[2].set_ylim([5, 18])
    ax1[2].grid(True)
    ax1[2].legend()

    # Adjust layout
    plt.tight_layout()

    # Constraints plot part=========================================================================================
    whole_span_his = history.getValues(names='Whole Span', major=True)['Whole Span']
    whole_span_his = np.delete(whole_span_his, error_index)

    wing_area_his = history.getValues(names='Wing Area', major=True)['Wing Area']
    wing_area_his = np.delete(wing_area_his, error_index)

    lambda_his = history.getValues(names='Taper Ratio', major=True)['Taper Ratio']
    lambda_his = np.delete(lambda_his, error_index)

    wing_weight_percentage_his = history.getValues(names='Wing Weight Percentage', major=True)['Wing Weight Percentage']
    wing_weight_percentage_his = np.delete(wing_weight_percentage_his, error_index)

    AR_his = history.getValues(names='Aspect Ratio Change', major=True)['Aspect Ratio Change']
    AR_his = np.delete(AR_his, error_index)

    fig2, ax2 = plt.subplots(5, 1, figsize=(9, 10))
    fig2.suptitle('Constraint History', fontsize=16)

    # Plot Whole Span history
    ax2[0].plot(whole_span_his, '-o', color='blue', label='Whole Span')
    ax2[0].set_title('Whole Span')
    ax2[0].set_xlabel('Iteration')
    ax2[0].set_ylabel('Whole Span [m]')
    ax2[0].grid(True)
    ax2[0].legend()

    # Plot Wing Area history
    ax2[1].plot(wing_area_his, '-o', color='green', label='Wing Area')
    ax2[1].set_title('Wing Area')
    ax2[1].set_xlabel('Iteration')
    ax2[1].set_ylabel('Wing Area [m^2]')
    ax2[1].grid(True)
    ax2[1].legend()

    # Plot Taper Ratio (lambda) history
    ax2[2].plot(lambda_his, '-o', color='red', label='Taper Ratio (λ)')
    ax2[2].set_title('Taper Ratio (λ)')
    ax2[2].set_xlabel('Iteration')
    ax2[2].set_ylabel('Taper Ratio [-]')
    ax2[2].grid(True)
    ax2[2].legend()

    # Plot Wing Weight Change history
    ax2[3].plot(wing_weight_percentage_his, '-o', color='magenta', label='Wing Weight Percentage')
    ax2[3].set_title('Wing Weight Percentage')
    ax2[3].set_xlabel('Iteration')
    ax2[3].set_ylabel('Wing Weight Percentage [%]')
    ax2[3].grid(True)
    ax2[3].legend()

    # Plot Aspect Ratio Change history
    ax2[4].plot(AR_his, '-o', color='cyan', label='Aspect Ratio Change')
    ax2[4].set_title('Aspect Ratio Change')
    ax2[4].set_xlabel('Iteration')
    ax2[4].set_ylabel('Aspect Ratio Change [%]')
    ax2[4].grid(True)
    ax2[4].legend()

    # Adjust layout
    plt.tight_layout()

    # obj plot part=========================================================================================
    range_his = -np.asarray(history.getValues(names='obj', major=True)['obj'])/1000
    range_his = np.delete(range_his, error_index)

    fig3, ax3 = plt.subplots(figsize=(9, 10))
    fig3.suptitle('Range History', fontsize=16)
    ax3.plot(range_his, '-o', color='cyan', label='Range')
    ax3.set_title('Range')
    ax3.set_xlabel('Iteration')
    ax3.set_ylabel('Range [km]')
    ax3.grid(True)
    ax3.legend()

    plt.show()

    pass


if __name__ == '__main__':
    pass
    # oper_point = OperPNT()
    # oper_point.beta_70 = 55.31
    # oper_point.rho = 1.225
    # oper_point.hub_radius = 0.376
    # oper_point.tip_radius = 1.88
    # # oper_point.RPM_list = list(range(700, 1001, 100))
    # oper_point.RPM_list = [800]
    # oper_point.Vinf = 142
    # oper_point.B = 6
    #
    # cpacs_ref = "./LILI/Do328_out/propTrue_RPM800/propTrue_RPM800.xml"
